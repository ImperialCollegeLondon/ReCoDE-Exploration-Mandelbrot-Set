{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#a-c-exploration-of-the-mandelbrot-set-and-the-use-of-scientific-visualization-tools","title":"A C++ Exploration of the Mandelbrot Set and the Use of Scientific Visualization Tools","text":""},{"location":"#description","title":"Description","text":"<p>The Mandelbrot set<sup>1</sup> is a well-known mathematical set, celebrated for its intricate, infinitely complex patterns that repeat at every scale. Since its popularization in the 1980s and 1990s, it has introduced new perspectives in mathematical visualization and complexity, with close links to other fields such as turbulence and computer graphics among others<sup>2</sup>. This project, \"A C++ Exploration of the Mandelbrot Set and the Use of Scientific Visualization Tools\", uses the visuals of the set to introduce students to key concepts in scientific computing.</p> <p>The goal of this ReCoDe (Research and Code Development) project is to help students immerse themselves in computational methods by using the Mandelbrot set as a practical example. This approach aims to make abstract concepts more accesible and engaging. The skills acquired from this project are especially helpful for those involved in high-performance computing (HPC), grid computing, and rapid computation, allowing students to apply their knowledge to fields that require handling complex data,efficient computation and scientific visualization. <code>C++</code> is chosen for this project because it is widely used in legacy codes that PhD students need to master and adapt quickly. </p> <p> Figure 1: The main goal of the ReCoDe project is to learn how to generate a high-quality fractal image and reach higher fidelity without increasing the computation time.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project is divided into three sections, which will cover the following points:</p>"},{"location":"#basic-mandelbrot-set-calculation","title":"Basic Mandelbrot Set Calculation","text":"<p>In this first section of the ReCoDe project, you will learn how to generate and perform operations on a 2D grid, transfer results directly to a high-quality picture format, and visualize them using tools like VTK. We will explore how to run iterations and inner loops efficiently using the STL (Standard Template Library) library. Additionally, you will receive guidance on measuring computation time with the <code>chrono</code> function and using a Makefile to streamline code compilation.</p>"},{"location":"#optimization-techniques","title":"Optimization Techniques","text":"<p>In this subsection, we will focus on improving the performance of the code from the first part by reducing its runtime through various multithreading paradigms and parallelization techniques all within the STL library. Specifically, we will explore using <code>std::thread</code>modifying the code to optimize its performance with these tools. We will demonstrate how these changes can reduce runtime by one-third. Additionally, you will learn how to parallelize the code for distributed-memory computer architectures, such as those used in HPC systems like CX1 and Archer2.</p>"},{"location":"#visualization-techniques","title":"Visualization Techniques","text":"<p>In this last subsection, we will focus on getting the output file in the VTK format so that we can postprocess it in ParaView and access its features. We will conclude with best practices in scientific vizualization to get a profesional rendered image.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Efficiently manipulate large 2D arrays (representing pixels of an image) using <code>std::vector</code> to store and process image data.</li> <li>Use complex numbers for mathematical computations.</li> <li>Implement nested loops to traverse and manipulate two-dimensional data structures.</li> <li>Use of STL headers such as <code>&lt;iostream&gt;</code>, <code>&lt;complex&gt;</code>, <code>&lt;fstream&gt;</code>, <code>&lt;vector&gt;</code>, and <code>&lt;chrono&gt;</code>.</li> <li>Synchronization and Communication in MPI.</li> <li>Output <code>C++</code> computational results directly into PPM (Portable Pixmap) and VTK (Visualization Toolkit) format files for image visualization. This includes extrusion to generate a 3D file.</li> <li>Important features of scientific visualization in Paraview.</li> <li>Best practices.</li> </ul> Task Time Reading 3 hours Practising 7 hours"},{"location":"#requirements","title":"Requirements","text":"<p>This project does not require prior knowledge of <code>C++</code> as there is an effot to explain each segment in detail to ensure the main ideas are clear. It is designed for readers familiar with Fortran, Matlab, or Python to learn the specifics of <code>C++</code>. The main goal is for readers to take the functions used here and apply them to their own problems.</p>"},{"location":"#system","title":"System","text":"<p>Installation instructions will be provided as needed. Except for a few cases, the project mainly uses features from the Standard Library. Some of the figures in the visualization section have been achieved using a 64BG RAM working station: however the reader can apply the same techniques on a much lower resolution image.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, it is best to first understand how the Mandelbrot set is defined (there is a brief introduction included) and how it is implemented in the code, then move on from there.</p> <p>References</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause license</p> <ol> <li> <p>Mandelbrot, B. B. (1980). The Fractal Geometry of Nature. New York: W.H. Freeman and Co.\u00a0\u21a9</p> </li> <li> <p>Barnsley, M. F. (1988). Fractals Everywhere. Academic Press, Inc.\u00a0\u21a9</p> </li> </ol>"},{"location":"Multithreading%20Techniques/Concepts/","title":"What happens when the code is executed in the single-threaded form?","text":"<p>As the image resolution increases (e.g., 1000  1000 pixels results in 1,000,000 iterations), the amount of computation becomes significant. The use of nested loops means that for each pixel, there are potentially up to <code>MAX_ITER</code> iterations, leading to a time complexity of . The nested loops for calculating the Mandelbrot set are run sequentially. Each pixel must be calculated before the next one starts, meaning that the larger the image, the longer it takes to compute.</p> <p>In terms of I/O operations, we have seen that the time required to write the output image to disk is negligible and is not a bottleneck (at least at the scale we are computing). This suggests that one of the main limitations lies in the operations inside the nested loops.</p> <p>The line <code>int num_cpus = std::thread::hardware_concurrency();</code> showed the number of concurrent threads supported by the hardware (12 CPU cores, which is standard in modern workstations). However, since the code runs in a single thread, during the execution of the nested loops, only one CPU core is fully utilized. The remaining cores remain idle unless other processes are running on the system. This leads to inefficient use of CPU resources, which could otherwise be leveraged by executing multiple threads simultaneously to speed up the overall computation.</p> <p>Regarding memory access, the nested loops can also be inefficient. The outer loop iterates over rows (<code>y</code>), while the inner loop iterates over columns (<code>x</code>). This pattern can lead to cache misses if data is not stored optimally in memory. Cache misses occur when the CPU searches for data in its cache but cannot find it, forcing it to retrieve data from the slower main memory (RAM). If the program utilized multiple threads, data access could be better arranged to make use of the cache, potentially improving performance.</p> <p></p> <p>Figure: Diagram showing a single-threaded execution.</p>"},{"location":"Multithreading%20Techniques/Multithreaded%20version/","title":"Multithreaded version","text":"<p>Multithreading  refers to the ability of a CPU (or a single core) to provide multiple threads of execution concurrently. Threads are the smallest parts of a program that can be managed by the operating system. In multithreading, multiple threads use the same memory but can run independently. This allows them to do different tasks or parts of a task at the same time which can make I/O-bound programs more efficient or help keep user interfaces responsive. This means they can do different jobs or parts of a job at the same time. Multithreading allows the main program to remain responsive while background tasks execute. In this context, concurrency is the ability of a system to manage multiple tasks at the same time, but not always at the exact same moment.</p> <p></p> <p>Figure: Diagram showing a Multithreaded execution.</p> <p>This code generates a high-resolution image of the Mandelbrot set using multithreading for faster computation concurrently. The code uses thread-based multithreading <code>&lt;thread&gt;</code> library. Specifically, it creates multiple threads, where each thread is assigned a portion of the Mandelbrot set computation (a range of rows of the image). This form of multithreading allows multiple parts of the task to run concurrently on different CPU cores, thus speeding up the overall computation.</p> <p>Each thread runs the <code>computeMandelbrotRows</code> function independently, processing its assigned rows of the image. Once all threads finish, the main program waits for them to complete using <code>thread.join()</code>. This type of multithreading is useful because of the use of multiple CPU cores efficiently.</p>"},{"location":"Multithreading%20Techniques/Multithreaded%20version/#mandelbrot-set-function-only-to-compute-a-certain-number-of-rows","title":"Mandelbrot set function only to compute a certain number of rows","text":"<pre><code>void computeMandelbrotRows(std::vector&lt;int&gt;&amp; iterations, int startRow, int endRow) {\n    for (int y = startRow; y &lt; endRow; ++y) {\n        for (int x = 0; x &lt; X; ++x) {\n            double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\n            double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n            std::complex&lt;double&gt; c(real, imag);\n            std::complex&lt;double&gt; z(0.0, 0.0);\n\n            int iter;\n            for (iter = 0; iter &lt; MAX_ITER; ++iter) {\n                if (std::abs(z) &gt; 2.0) break;\n                z = z * z + c;\n            }\n\n            iterations[y * X + x] = iter;\n        }\n    }\n}\n</code></pre> <p>Function configuration: The primary function of <code>computeMandelbrotRows</code> is to calculate the Mandelbrot set for a specific range of rows in the 2D pixel grid, storing the results in a given vector of integers. Note that <code>void</code> is used here to indicate that the function does not return any value. It directly modifies the contents of the <code>iterations</code> vector passed by reference. Since the goal of the function is to update the state of the <code>iterations</code> vector rather than produce a new result to be returned, a <code>void</code> return type is appropriate. This is quite commonly used in C++ when you want to perform actions rather than compute a value.</p> <p>Also, by using a reference parameter (<code>std::vector&lt;int&gt;&amp; iterations</code>), the function can modify the contents of the vector without the overhead of copying it. This approach avoids unnecessary memory usage. Note the use of <code>&amp;</code>, which is the symbol that allows the function to accomplish that.</p> <p>The range of the function is specific and does not include the whole 2D grid. <code>int startRow</code> is the starting row index for the computation, and <code>int endRow</code> is the ending row index (exclusive).</p> <p>Nested loop: The main idea is that <code>computeMandelbrotRows</code> iterates from <code>startRow</code> to <code>endRow</code>, allowing threads to operate on different segments without overlap. The commands for mapping the image coordinates, creating the complex number, applying the Mandelbrot formula, and storing the iterations count are exactly the same as in the single-threaded version. We are also not timing anything here, as this function will be called concurrently.</p>"},{"location":"Multithreading%20Techniques/Multithreaded%20version/#general-mandelbrot-set-function-that-uses-multithreading","title":"General Mandelbrot set function that uses multithreading","text":"<p>The <code>computeMandelbrotParallel()</code> function uses multithreading to compute the Mandelbrot set efficiently. It achieves this by dividing the workload among the available CPU threads. These threads enhance performance and reduce computation time. Each thread is assigned a specific range of rows to process, allowing multiple calculations to occur simultaneously. The keyword here is concurrent execution within a single process. Additionally, the function employs <code>std::vector</code> to manage the results and <code>std::thread</code> to facilitate parallel execution. This ensures that the data is handled effectively during the computation process.</p> <pre><code>std::vector&lt;int&gt; computeMandelbrotParallel() {\n    std::vector&lt;int&gt; iterations(X * Y);\n\n    int numThreads= std::thread::hardware_concurrency();\n\n    std::vector&lt;std::thread&gt; threads; //Empty vector\n    threads.reserve(numThreads); // Reserve option\n\n    int rowsPerThread = Y / numThreads;\n\n    for (int i = 0; i &lt; numThreads; ++i) {\n        int startRow = i * rowsPerThread;\n        int endRow = (i == numThreads - 1) ? Y : (i + 1) *rowsPerThread;\n        threads.emplace_back(computeMandelbrotRows, std::ref(iterations),startRow,endRow);// Add new threads one by one to the vector as you create them\n    }\n    //Command needed, similar to MPI_Allreduce or MPI_GATHER\n    for (auto&amp; thread : threads) {\n        thread.join();\n    }\n\n    return iterations;\n}\n</code></pre> <p>Function configuration and vector initialization:</p> <p>The <code>computeMandelbrotParallel()</code> function returns a <code>std::vector&lt;int&gt;</code> that stores the number of iterations for each pixel in the Mandelbrot set computation. Here, the function does not take any parameters <code>()</code> because we design it to focus on computing the Mandelbrot set globally. For this reason, it does not require any additional input from the caller. </p> <p>Following this, we initialized a vector called <code>iterations</code> with a size equal to the total number of pixels in the image (<code>X * Y</code>), just like we did in the original code. <code>return iterations;</code> enables the computed iteration counts from the Mandelbrot set calculation to be returned to the calling function. This allows for further processing or output of the results. </p> <p>Determine number of threads and thread vector initialization</p> <p>We need to determine the number of concurrent threads that the hardware (CPU) can support. The function <code>std::thread::hardware_concurrency()</code> returns the number of threads that the implementation can run concurrently. We will use <code>numThreads</code> in the calculations.</p> <p>Following this, we need to declare a vector named <code>threads</code> to hold the threads that will be created. <code>std::vector&lt;std::thread&gt; threads;</code> declares an empty vector named <code>threads</code> that will store objects of type <code>std::thread</code>. This is the same vector that we have been using and that is provided by the Standard Library which can grow and shrink in size as needed.</p> <pre><code>std::vector&lt;std::thread&gt; threads; // Empty vector\n</code></pre> <p>The <code>reserve(numThreads)</code> function is called to allocate enough memory for the number of threads which can improve performance by avoiding multiple reallocations as threads are added. This is in some ways similar to allocation in Matlab or Fortran. We access members (functions and variables) of the <code>threads</code> object with the <code>.</code> operator. The <code>reserve(size_type n)</code> function is a member function of the <code>std::vector</code> class. Its primary purpose is to allocate memory, and it remains zero until you actually add elements to it.</p> <pre><code>threads.reserve(numThreads); // Reserve option\n</code></pre> <p>Calculate Rows-Per-Thread This line calculates the number of rows that each thread will process. It ensures that the workload is distributed evenly among the available threads.</p> <pre><code>int rowsPerThread = Y / numThreads;\n</code></pre> <p>Thread loop This loop divides the task of processing rows of an image into chunks. Each thread is assigned a specific range of rows to work on, determined by <code>startRow</code> and <code>endRow</code>. The <code>startRow</code> and <code>endRow</code> values define the portion of the total rows that each thread will handle. The last thread is assigned any remaining rows to ensure that all rows are processed. This is important when <code>Y</code> (the total number of rows) is not evenly divisible by <code>numThreads</code>.</p> <p><pre><code>for (int i = 0; i &lt; numThreads; ++i) {\n        int startRow = i * rowsPerThread;\n        int endRow = (i == numThreads - 1) ? Y : (i + 1) * rowsPerThread;\n        // Continuation of the body of the function\n    }\n</code></pre> This technique shown in the command is quite commonly used in parallel programming or multithreading to divide a large task into smaller tasks. The line <code>int startRow = i * rowsPerThread;</code> calculates the starting row index for each thread. <code>(i == numThreads - 1)</code> checks if the current thread <code>i</code> is the last thread (since <code>numThreads - 1</code> is the index of the last thread in a 0-based index system). <code>? Y:</code> uses the ternary operator which basically means <code>condition ? value_if_true : value_if_false;</code>. If <code>i</code> is the last thread, the <code>endRow</code> is set to <code>Y</code>. This means the last thread processes all remaining rows up to the end of the dataset. This is done to ensure that the division of work is exact, even if <code>Y</code> is not evenly divisible by <code>numThreads</code>. If <code>i</code> is not the last thread, then <code>endRow</code> is set to <code>(i + 1) * rowsPerThread</code> which gives the end of the current portion of rows of the thread.</p> <p>Threads creation Inside the thread loop, the following line is responsible for creating a new thread and adding it to the <code>threads</code> vector. This allows for simultaneous computation of different sections of the Mandelbrot set, speeding up the process.</p> <pre><code>threads.emplace_back(computeMandelbrotRows, std::ref(iterations), startRow, endRow);\n</code></pre> <p>We access the container that stores thread objects <code>threads</code> and we use <code>emplace_back(...)</code>. This is a member function of <code>std::vector</code> that constructs and adds a new element to the end of the vector. In this case, it constructs a new <code>std::thread</code> object. <code>computeMandelbrotRows</code> is the name of the function that will be executed by the newly created thread. Each thread will execute this function concurrently.</p> <p><code>std::ref(iterations)</code> wraps the <code>iterations</code> vector in a <code>std::reference_wrapper</code>. This is important because the <code>computeMandelbrotRows</code> function takes the <code>iterations</code> vector by reference (<code>std::vector&lt;int&gt;&amp; iterations</code>). Using <code>std::ref</code> ensures that the vector is not copied; instead, a reference to the original vector is passed to the thread. This allows multiple threads to modify the same <code>iterations</code> vector without creating separate copies which would be inefficient. <code>startRow</code> and <code>endRow</code> are the starting and ending row indices calculated for each thread. Each thread processes the range of rows assigned to it during computation.</p> <p>Joining threads This loop iterates through the <code>threads</code> vector and calls <code>join()</code> on each thread. This makes the main thread wait for all the created threads to complete their execution before moving forward. The purpose of this is to synchronize the threads.</p> <p><code>for (auto&amp; thread : threads)</code> is a loop that goes through each thread in the <code>threads</code> vector. <code>auto&amp;</code> figures out the type of <code>thread</code> automatically and makes sure we are working with the actual thread, again avoiding unnecessary copies. The <code>&amp;</code> is important because it lets us handle the original <code>std::thread</code> objects directly.</p> <p>In <code>thread.join()</code>, the <code>join()</code> function is a part of <code>std::thread</code> that makes the main thread wait until the thread it is called on has finished running. This means the main thread will not move on until the thread completes its task. If <code>join()</code> is not called, the main thread might finish and close the program before the worker threads are done. This can lead to problems like incomplete work or errors. This should always be included at the end of the function.</p> <pre><code>for (auto&amp; thread : threads) {\n    thread.join();\n}\n</code></pre>"},{"location":"Multithreading%20Techniques/Multithreaded%20version/#the-caller-function","title":"The caller function","text":"<p>This function, as in the original code, orchestrates the entire program, coordinating various operations. The only difference is that this time it calls the <code>computeMandelbrotParallel()</code> function to compute the Mandelbrot set using multiple threads. Also, this is the only function that has timing measurements which are exactly in the same form as in the original code.</p>"},{"location":"Multithreading%20Techniques/Multithreaded%20version/#the-output","title":"The output","text":"<p>We compile the code as follows. <pre><code> g++ -std=c++11 -o mandelbrot mandelbrot_set_exploration_std_thread.cpp -pthread\n</code></pre> Execute the command <pre><code> ./mandelbrot\n</code></pre></p> <p>Here, we print-out the total time spent on scaling coordinates and performing iterations. <pre><code>Width of the image:5000\nHeight of the image: 5000\nTotal time taken to compute the Mandelbrot set with Multithreading: 69.5359 seconds\nNumber of CPUs available: 12\nTotal time it takes to generate image: 6.30912 seconds\nMandelbrot set with colormap: mandelbrot_gradient.ppm\n</code></pre> This multithreaded version runs approximately 4.15 times faster than single-threaded version.</p>"},{"location":"Multithreading%20Techniques/Parallel%20version%20using%20MPI/","title":"Parallel version using MPI","text":"<p>Parallelism on the other hand, means running multiple tasks or processes at the same time on different CPU cores or machines. It is more a broader idea that includes any situation where tasks are done at the same time. In parallelism, the tasks can work independently and do not need to use the same memory. This can be done in different ways, for example using multi-core CPUs, distributed computing, or parallel processing systems. Parallelism works best for tasks that require a lot of computing power and can be split into independent smaller tasks, like numerical simulations, processing large amounts of data or rendering images. Most important aspect is that this enable us to run our work in HPC clusters.</p> <p></p> <p>Figure: Diagram showing a Paralell execution using MPI.</p> <p>This code shows the parallelized version of the single-threaded version using Message Passing Interface (MPI). MPI is a standardized and portable message-passing system (think of a protocol) that helps processes communicate in a distributed computing environment. It allows different processes that run on separate machines to exchange messages and coordinate their actions, making it essential for high-performance computing tasks. In the case that we need to increase the number of processors beyond our workstation or require more RAM than is available, MPI helps distribute the workload across more processes by running tasks in parallel and collecting the results in one place.</p> <p>We will explain step by step the sections of the code. The computation of different rows of the Mandelbrot set is split among multiple processes. Each process calculates a set of rows based on its rank in the MPI communicator. The <code>compute_Mandelbrot_equation</code> function is exactly the same as in the single-threaded version. However, this time <code>MPI_Gather</code> collects the results from all processes into a single buffer on the root process (rank 0). The root process then assembles and saves the image in PPM format using <code>save_ppm</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;mpi.h&gt;\n\nconstexpr int X = 5000;       // Width(X)\nconstexpr int Y = 5000;       // Height(Y)\nconstexpr int MAX_ITER = 1000;   // Maximum number of iterations\nconstexpr double X_MIN = -2.0;   // Maximum x-axis value\nconstexpr double X_MAX = 1.0;    // Maximum x-axis value\nconstexpr double Y_MIN = -1.5;   // Maximum y-axis value\nconstexpr double Y_MAX = 1.5;    // Maximum y-axis value\n\nstd::vector&lt;int&gt; compute_Mandelbrot_equation(int start_row,int num_rows) {\n    std::vector&lt;int&gt; iterations(num_rows * X);\n\n    for (int y = start_row; y &lt; start_row + num_rows; ++y) {\n        for (int x = 0; x &lt; X; ++x) {\n            double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\n            double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n\n            std::complex&lt;double&gt; c(real, imag);\n            std::complex&lt;double&gt; z(0.0, 0.0);\n\n            int iter;\n            for (iter = 0; iter &lt; MAX_ITER; ++iter) {\n                if (std::abs(z) &gt; 2.0) break;\n                z = z * z + c;\n            }\n            iterations[(y - start_row) * X + x] = iter;\n        }\n    }\n    return iterations;\n}\n\nvoid save_ppm(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n    std::ofstream ofs(filename, std::ios::binary);\n\n    ofs &lt;&lt; \"P6\\n\" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \"\\n255\\n\";\n\n    for (int i = 0; i &lt; X * Y; ++i) {\n        int iter = iterations[i];\n        unsigned char r = static_cast&lt;unsigned char&gt;(iter % 256);\n        unsigned char g = static_cast&lt;unsigned char&gt;((iter *2) % 256);\n        unsigned char b = static_cast&lt;unsigned char&gt;((iter *5) % 256);\n        ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b;\n    }\n\n    ofs.close();\n}\n// This is structured/standard MPI input\nint main(int argc, char** argv) {\n    MPI_Init(&amp;argc, &amp;argv);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);\n\n    int num_rows = Y / size;\n    int start_row = rank * num_rows;\n    if ( rank == size - 1) {\n        num_rows = Y - start_row; // Last process takes the remaining rows\n    }\n\n    std::cout &lt;&lt; \"Width(X) of the image: \" &lt;&lt; X  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Height(Y) of the image: \" &lt;&lt; Y &lt;&lt; std::endl;\n\n    auto start_compute = std::chrono::high_resolution_clock::now();\n    std::vector&lt;int&gt; local_iterations = compute_Mandelbrot_equation(start_row, num_rows);\n    auto end_compute = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_compute = end_compute -start_compute;\n    std::cout &lt;&lt; \"Process \" &lt;&lt; rank &lt;&lt; \" completed in: \" &lt;&lt; elapsed_compute.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    std::vector&lt;int&gt; global_iterations;\n    if (rank == 0) {\n        global_iterations.resize(X * Y);\n    }\n\n    MPI_Gather(local_iterations.data(),num_rows*X,MPI_INT,global_iterations.data(),num_rows*X,MPI_INT,0,MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        auto start_save = std::chrono::high_resolution_clock::now();\n        save_ppm(global_iterations, \"mandelbrot_gradient.ppm\");\n        auto end_save = std::chrono::high_resolution_clock::now();\n        std::chrono::duration&lt;double&gt; elapsed_save = end_save - start_save;\n        std::cout &lt;&lt; \"Time it takes to generate image: \" &lt;&lt; elapsed_save.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Mandelbrot set with colormap output: mandelbrot_gradient.ppm\"&lt;&lt; std::endl;\n    }\n\n    MPI_Finalize();\n    return 0;\n}\n</code></pre>"},{"location":"Multithreading%20Techniques/Parallel%20version%20using%20MPI/#the-header","title":"The Header","text":"<p>Note that the only additional header is <code>&lt;mpi.h&gt;</code>. This header enables parallelism by providing MPI functions needed to split the computation among multiple processes. MPI is not included in the C++ standard library.</p> <p>MPICH is a popular open-source implementation of the MPI standard. It is built for high performance and works on many types of parallel computing systems, including clusters and supercomputers. On Ubuntu, MPICH can be installed easily as a pre-compiled package from the default software repositories.</p> <p><pre><code>sudo apt update\nsudo apt install mpich libmpich-dev\n</code></pre> Once the installation is completed, you can check the version of MPICH to confirm the installation as follows, <pre><code>mpirun --version\n</code></pre></p>"},{"location":"Multithreading%20Techniques/Parallel%20version%20using%20MPI/#the-mandelbrot-set-main-computation","title":"The Mandelbrot set main computation","text":"<p>The Mandelbrot set main computation <code>compute_Mandelbrot_equation()</code> presented below has some changes compared to the single-threaded version. These differences show the change from a simple implementation to a parallelized approach.</p> <pre><code>std::vector&lt;int&gt; compute_Mandelbrot_equation(int start_row, int num_rows) {\n    std::vector&lt;int&gt; iterations(num_rows * X);\n\n    for (int y = start_row; y &lt; start_row + num_rows; ++y) {\n        for (int x = 0; x &lt; X; ++x) {\n            double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\n            double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n\n            std::complex&lt;double&gt; c(real, imag);\n            std::complex&lt;double&gt; z(0.0, 0.0);\n\n            int iter;\n            for (iter = 0; iter &lt; MAX_ITER; ++iter) {\n                if (std::abs(z) &gt; 2.0) break;\n                z = z * z + c;\n            }\n            iterations[(y - start_row) * X + x] = iter;\n        }\n    }\n    return iterations;\n}\n</code></pre> <p>The Main Function Definition</p> <p>In the single-threaded version, <code>std::vector&lt;int&gt; compute_Mandelbrot_equation()</code> computed the entire Mandelbrot set in one go, as there are no other processes to communicate with. All calculations for the image size  are done in a single function call. The situation is different now because we aim to divide the work between processors. In parallel computing with MPI, each process handles only part of the total data. For this reason, the function is designed to take the starting row <code>start_row</code> and the number of rows <code>num_rows</code> to process as inputs which helps divide the work between processes.</p> <p>Initialisation and declaration of the variables: Inside the function, we proceed with the initialisation and declaration of the <code>iterations</code> vector. <pre><code>std::vector&lt;int&gt; compute_Mandelbrot_equation(int start_row, int num_rows) {\n    std::vector&lt;int&gt; iterations(num_rows * X);\n    // Body of the function\n    return iterations;\n}\n</code></pre> <code>num\\_rows * X</code> gives the total number of pixels that need to be stored in the \\texttt{iterations} vector for the specific rows assigned to that thread or process.  <pre><code>std::vector&lt;int&gt; iterations(num_rows * X);\n</code></pre> Each process computes the Mandelbrot set for a subset of the image rows. The image rows <code>Y</code> are divided among the available processes (size), where <code>num_rows</code> is the number of rows given to each MPI process and <code>X</code> remains the total number of columns (width) in the image. Since each process calculates only a portion of the rows, it only needs memory for those specific rows. This reduces memory usage and is important for large images or systems with limited resources. <code>return iterations;</code> enables the computed iteration counts from the Mandelbrot set calculation to be returned to the calling function. This allows for further processing or output of the results.</p> <p>Partial nested loop: In the single-threaded version, the nested loop goes through every pixel in the image sequentially. In this MPI version however, the outer loop processes only the rows assigned to the current MPI process. Note, that the inner loop remains the same because we cover the whole length of the columns. <pre><code>for (int y = start_row; y &lt; start_row + num_rows; ++y) {\n    for (int x = 0; x &lt; X; ++x) {\n        // The mapping of image coordinates to the complex plane remains the same.\n        // The creation of complex numbers and Mandelbrot formula remains also the same.\n\n    }\n}\n</code></pre> This is important for balancing the workload particularly in this nested loop which is the critical component of the code in terms of performance, letting each process work on its own part of the image at the same time. The mapping of image coordinates to the complex plane and the creation of complex numbers in the MPI version remains the same as in the single-threaded version because regardless of how many processes are used, the same mapping and use of the same formula ensures that each process computes the Mandelbrot set correctly and produces identical results.</p> <p>Storing the iteration count in the vector: </p> <p>Here the same applies. The indexing takes into account the rows processed by the current MPI process, requiring an adjustment based on <code>start\\_row</code>. Both versions return a vector of iterations, but the MPI version only returns the rows calculated by that specific process, while the single-threaded version returns the entire image data.</p>"},{"location":"Multithreading%20Techniques/Parallel%20version%20using%20MPI/#main-mpi-function","title":"Main MPI function","text":"<p>This is the main MPI function that orchestrates the entire workflow of the program.</p> <pre><code>int main(int argc, char** argv) {\n    MPI_Init(&amp;argc, &amp;argv);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);\n\n    int num_rows = Y / size;\n    int start_row = rank * num_rows;\n    if ( rank == size - 1) {\n        num_rows = Y - start_row; // Last process takes the remaining rows\n    }\n\n    std::cout &lt;&lt; \"Width(X) of the image: \" &lt;&lt; X  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Height(Y) of the image: \" &lt;&lt; Y &lt;&lt; std::endl;\n\n    auto start_compute = std::chrono::high_resolution_clock::now();\n    std::vector&lt;int&gt; local_iterations = compute_Mandelbrot_equation(start_row, num_rows);\n    auto end_compute = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_compute = end_compute -start_compute;\n    std::cout &lt;&lt; \"Process \" &lt;&lt; rank &lt;&lt; \" completed in: \" &lt;&lt; elapsed_compute.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    std::vector&lt;int&gt; global_iterations;\n    if (rank == 0) {\n        global_iterations.resize(X * Y);\n    }\n\n    MPI_Gather(local_iterations.data(),num_rows*X,MPI_INT,global_iterations.data(),num_rows*X,MPI_INT,0,MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        auto start_save = std::chrono::high_resolution_clock::now();\n        save_ppm(global_iterations, \"mandelbrot_gradient.ppm\");\n        auto end_save = std::chrono::high_resolution_clock::now();\n        std::chrono::duration&lt;double&gt; elapsed_save = end_save - start_save;\n        std::cout &lt;&lt; \"Time it takes to generate image: \" &lt;&lt; elapsed_save.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; \"Mandelbrot set with colormap output: mandelbrot_gradient.ppm\"&lt;&lt; std::endl;\n    }\n\n    MPI_Finalize();\n    return 0;\n}\n</code></pre> <p>Definition of the main function: Exactly as in the single-threaded version, <code>int</code> indicates that the function returns an integer. This is used as the exit status of the program. <code>main</code> is the name of the function that the operating system calls when the program starts. <code>int argc</code> is the argument count and indicates the number of command-line arguments passed to the program. <code>char** argv</code> is the argument vector which is an array of C-strings or character arrays representing the actual arguments. There might be more to say about this type of setting; however, it is important to note that in MPI applications, it is common to initialize the MPI environment with <code>MPI_Init(&amp;argc, &amp;argv)</code>, ensuring compatibility with the initialization requirements of the MPI library.</p> <p><code>MPI_Finalize()</code> cleans up the MPI environment and frees any resources used by MPI. This should be the last MPI function called in the program. It is a good practice to include it to avoid memory leaks and other issues. <code>return 0;</code> as previously used, indicates that the program finished successfully.</p> <p>MPI Initialization: <code>MPI_Init</code> sets up the MPI environment. It must be called before using any other MPI functions. By calling <code>MPI_Init</code>, you prepare the MPI library for operation. This includes the ability to create and manage processes.</p> <p>MPI ranks and sizes: Here, we retrieve and store information about the parallel processes. <code>rank</code> is assigned the unique identifier of the calling process (it ranges from 0 to <code>size</code> - 1), while <code>size</code> holds the total number of processes being used in the program. This information is crucial for coordinating tasks among the processes because it allows each process to know its own identity (<code>rank</code>) and how many processes are used in the computation (<code>size</code>).</p> <p><code>int rank, size;</code> declares the two integer variables used for this information. <code>MPI_Comm_rank</code> retrieves the rank (ID) of the calling process in the specified communicator (<code>MPI_COMM_WORLD</code> includes all processes). The information is stored in the <code>rank</code> variable. <code>MPI_Comm_size</code> retrieves the total number of processes in the specified communicator and stores it in the <code>size</code> variable.</p> <p>Distribution of the row for Computation: Here, we divide the workload of generating the Mandelbrot set among multiple processes. It calculates how many rows of the image each process should handle by dividing the total number of rows <code>Y</code> by the number of processes (<code>size</code>). The variable <code>start_row</code> determines the starting row for each process based on its rank. If the process is the last one (indicated by <code>rank == size - 1</code>), it adjusts <code>num_rows</code> to account for any remaining rows so that all rows of the image are processed, even if the number of rows does not divide evenly among the processes.</p> <pre><code>int num_rows = Y / size;\nint start_row = rank * num_rows;\nif (rank == size - 1) {\n    num_rows = Y - start_row; // Last process takes the remaining rows\n}\n</code></pre> <p><code>int num_rows = Y / size;</code> calculates how many rows of the image each process will compute by dividing the total number of rows <code>Y</code> by the number of processes (<code>size</code>).</p> <p><code>int start_row = rank * num_rows;</code> calculates the starting row for the current process based on its rank. For example, process 0 starts at row 0, process 1 starts at <code>num_rows</code>, and so on.</p> <p><code>if (rank == size - 1)</code> checks if the current process is the last one (highest rank). If this is the case, <code>num_rows = Y - start_row;</code> adjusts <code>num_rows</code> to account for any remaining rows that could not be evenly divided.</p> <p>Execution of functions and its timing:</p> <p>Here, we measure the time it takes for each MPI process to compute its assigned portion of the Mandelbrot set. The measurement of the time is exactly analogous to what we presented previously. It begins by capturing the current time before the computation using <code>std::chrono::high_resolution_clock::now()</code>. Then, it calls the <code>compute_Mandelbrot_equation</code> function which performs the actual calculation for the designated rows of the image. After the computation is complete, it captures the end time and calculates the elapsed time.</p> <p><code>compute_Mandelbrot_equation(start_row, num_rows):</code> Calls the function to compute the Mandelbrot set for the assigned rows. The results are stored in <code>local_iterations</code>. The values of <code>start_row</code> and <code>num_rows</code> are explicitly calculated in the previous steps. Note that here we are also initializing the <code>local_iterations</code> vector (<code>std::vector&lt;int&gt;</code>).</p> <p>Gathering Results and MPI Gather:</p> <p>The goal is to gather the results of the set computations from all MPI processes and combine them into a single data structure on the root process. The root process is the process that has the rank of 0 in the communication group. It is the designated coordinator for collective operations. First, an empty vector called <code>global_iterations</code> is created to store the combined results. If the current process is the root (rank 0), it resizes <code>global_iterations</code> to fit the total number of pixels in the image. This is calculated as <code>(X * Y)</code>.</p> <p>After this, the <code>MPI_Gather</code> function is used to collect the individual results stored in <code>local_iterations</code> from each process. Each process sends its computed data which is the size of <code>num_rows * X</code>, to the root process. The root process then combines all this data into <code>global_iterations</code>. This process allows the root to access the complete set of iteration counts for the entire image, making it possible to save the final output as a PPM file.</p> <p>In other words, the <code>global_iterations</code> vector is constructed from <code>local_iterations</code> through the <code>MPI_Gather</code> function and consolidates it into a single vector on the root process (rank 0).</p> <pre><code>std::vector&lt;int&gt; global_iterations;\nif (rank == 0) {\n    global_iterations.resize(X * Y);\n}\nMPI_Gather(local_iterations.data(), num_rows * X, MPI_INT, global_iterations.data(), num_rows * X, MPI_INT, 0, MPI_COMM_WORLD);\n</code></pre> <p><code>MPI\\_Gather</code> follows a structured input form presented below taken directly from MPICH website which we can \"fill out\" with our inputs.</p> <pre><code>int MPI_Gather(const void *sendbuf,int sendcount,MPI_Datatype sendtype,\n               void *recvbuf,int recvcount,MPI_Datatype recvtype,int root,MPI_Comm comm)\n</code></pre> <ul> <li> <p>sendbuf   Starting address of the send buffer (choice). Our code: <code>local_iterations.data()</code> is the starting address of the send buffer and contains the local computed iterations for the current process. The <code>.data()</code> method retrieves a pointer to the underlying array. A pointer is a variable that stores the memory address of another variable.</p> </li> <li> <p>sendcount   Number of elements in the send buffer (integer). Our code: <code>num_rows * X</code> specifies the number of elements in the send buffer for each process. This is the number of rows each process computed multiplied by the width of the image (<code>X</code>).</p> </li> <li> <p>sendtype   Data type of send buffer elements (handle). Our code: <code>MPI_INT</code> indicates the data type of the elements in the send buffer which is an integer.</p> </li> <li> <p>recvbuf   Address of the receive buffer (choice, significant only at root). Our code: <code>global_iterations.data()</code> is the starting address of the receive buffer where the gathered data will be stored at the root process (rank 0).</p> </li> <li> <p>recvcount   Number of elements for any single receive (integer, significant only at root). Our code: We repeat again <code>num_rows * X</code>. This time it specifies that the root process will expect to receive this many integers from each process.</p> </li> <li> <p>recvtype   Data type of receive buffer elements (significant only at root) (handle). Our code: <code>MPI_INT</code> indicates the data type of the elements in the receive buffer which is also an integer.</p> </li> <li> <p>root   Rank of the receiving process (integer). Our code: 0. This is the rank of the root process that will receive the data.</p> </li> <li> <p>comm   Communicator (handle). Our code: <code>MPI_COMM_WORLD</code> is the communicator that includes all the processes.</p> </li> </ul> <p>Saving results and its timing: We proceed with saving the results and obtaining the time the code needs to accomplish that. We ensure that only the root process (rank 0) performs the file writing operation. This prevents multiple processes from attempting to write to the same file simultaneously. This is a standard operation using MPI to prevent data corruption or errors.</p> <p><code>save_ppm(global_iterations, \"mandelbrot_gradient.ppm\");</code> calls a function to save the gathered results (from all the processes) into a PPM image file named <code>\"mandelbrot_gradient.ppm\"</code>. Note that we are passing <code>global_iterations</code> to the <code>save_ppm</code> function.</p>"},{"location":"Multithreading%20Techniques/Parallel%20version%20using%20MPI/#the-oputput","title":"The oputput","text":"<p>Compile the code on Ubuntu as follows, <pre><code>mpic++ -o mandelbrot mandelbrot_set_exploration_main_code_MPI.cpp\n</code></pre> After this run the code with for example 12 processors. <pre><code>mpirun -np 12 ./mandelbrot\n</code></pre> The total time that the code needed to compute was around 274 seconds which close to the single-thread version.</p> <p>Multithreading version can take advantage of shared memory architectures (i.e. laptops) and less overhead. MPI is designed to work on HPCs:  Using my laptop, which is a shared memory device with 12 cores, I have achieved computation times that are around one-fourth of those taken by the single-threaded version with the multithreaded version. However, the MPI version is much slower than the other two. This should not be a surprise, as MPI is designed to work on distributed memory architectures. Using MPI and multithreading together can significantly improve performance and for large-scale applications running on multi-core and distributed systems and it is something worth exploring. </p> <p>In shared memory systems, like multi-core CPUs, multiple threads can work together using the same memory space. This means they can directly share data, like the <code>iterations</code> vector in this code, and each thread computes a different part of the image. On the other hand, in distributed memory systems using MPI, each process has its own separate memory. These processes do not share data directly but instead communicate by sending messages to each other with the final results collected by a main process. The MPI version gathers results from multiple processes and this involves sending and receiving data which slows down in a shared memory architecture. The purpose of the MPI is so you can use it in HPC clusters.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Initial%20setup%20for%20Windows%20and%20Ubuntu%20users/","title":"Initial setup for Windows and Ubuntu users","text":"<p>To run the provided C++ code on both Windows and Ubuntu, you need to set up a C++ development environment with a suitable compiler. The instructions below will help you get everything set up for each operating system. We will also introduce the use of CMake. For convenience, we will use the main Mandelbrot set code. We will describe the functionality of this code in detail in the next chapters.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Initial%20setup%20for%20Windows%20and%20Ubuntu%20users/#windows-setup-using-windows-wsl","title":"Windows Setup (Using Windows WSL)","text":"<p>I recommend using Windows WSL (Windows Subsystem for Linux) for this ReCoDe. This option enables the use of Linux on a Windows machine in a direct and easy manner without the need for Virtual Machines or emulators.</p> <ol> <li>Go to the Windows WSL website.</li> <li>Follow the instructions to set up WSL and configure the necessary settings.</li> <li>Once WSL is installed, you can follow the standard Ubuntu instructions for setting up a C++ development environment as you will see next.</li> </ol>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Initial%20setup%20for%20Windows%20and%20Ubuntu%20users/#ubuntu-setup","title":"Ubuntu Setup","text":""},{"location":"The%20main%20Mandelbrot%20set%20calculation/Initial%20setup%20for%20Windows%20and%20Ubuntu%20users/#install-gcc-gnu-compiler-collection","title":"Install GCC (GNU Compiler Collection)","text":"<ol> <li>Open the terminal and install GCC and necessary build tools: <pre><code>sudo apt update\nsudo apt install build-essential\n</code></pre></li> </ol>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Initial%20setup%20for%20Windows%20and%20Ubuntu%20users/#compiling-and-running-the-code","title":"Compiling and Running the Code","text":"<ol> <li>Navigate to the directory where your <code>.cpp</code> file is located using the terminal. Use the command <code>pwd</code> if you need to locate your directory.</li> <li>Compile the code with the following command: <pre><code>   g++ -o mandelbrot mandelbrot.cpp -std=c++11\n</code></pre></li> <li>Run the executable: <pre><code>./mandelbrot\n</code></pre></li> </ol> <p>You should see the following output on your screen and we are ready to go:</p> <pre><code>Width of the image:5000\nHeight of the image: 5000\nTotal scaling time: 0.007769 seconds\nTotal iteration time: 275.241 seconds\nTotal time taken to compute the Mandelbrot set (single-threaded version): 288.617 seconds\nNumber of CPUs used: 12\nTotal time it takes to generate image: 6.57477 seconds\nMandelbrot set with colormap: mandelbrot_gradient.ppm\n</code></pre>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/","title":"Introduction to the Mathematics of the Mandelbrot Set","text":"<p>The Mandelbrot set (Mandelbrot1980) was discovered by Beno\u00eet B. Mandelbrot in the late 1970s and is considered a revolutionary development in mathematics due to its intricate and infinitely complex structure. This set, visualized using complex numbers, exhibits self-similarity and fractal boundaries. The visualization of the Mandelbrot set using computer graphics sparked widespread fascination, showcasing the power of computers to render stunning, detailed images (ScientificAmerican1985). This intersection of mathematics and digital art played an important role in popularizing fractals and advancing computer graphics technology (Barnsley1988Science). We will present the necessary mathematics to understand the set next.</p> <p></p> <p>Figure 2: Scientific American cover August 1985.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#complex-numbers-the-input","title":"Complex Numbers (the input)","text":"<p>A complex number is expressed in the form , where:</p> <ul> <li>  is the real part,</li> <li>  is the imaginary part, and</li> <li>  is the imaginary unit, defined by .</li> </ul> <p>For instance,  is a complex number with a real part of 3 and an imaginary part of 4.</p> <p>Complex numbers can be represented in Cartesian (real and imaginary parts) and polar (magnitude and angle) forms.</p> <p></p> <p>Figure 3: Geometric representation of the complex number  in the complex plane (source: Wikipedia).</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#the-mandelbrot-iteration-the-output","title":"The Mandelbrot Iteration (the output)","text":"<p>The Mandelbrot set is defined by iterating the function:</p> <p> </p> <p>Here,  is a complex number representing a point in the complex plane, and we start with  (i.e., ).</p> <p>The iteration proceeds as follows:</p> <ol> <li>Begin with .</li> <li>Compute .</li> <li>Continue iterating: .</li> </ol> <p>The main question is: Does the sequence remain bounded, or does it escape to infinity?</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#determining-membership-in-the-mandelbrot-set","title":"Determining Membership in the Mandelbrot Set","text":"<p>A point  belongs to the Mandelbrot set if, starting from , the sequence  (the magnitude of ) does not tend to infinity as  increases. In practical terms, if at any iteration , the sequence will diverge, and the point  is not in the Mandelbrot set.</p> <p>To visualize the Mandelbrot set, we plot points on the complex plane and color them based on the number of iterations required for  to exceed 2. Points that do not escape are usually colored black, indicating they are part of the Mandelbrot set.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#example-1-a-number-that-iterates-a-lot-belongs-to-the-mandelbrot-set-and-is-colored-by-a-single-color","title":"Example 1: A Number that iterates a lot (belongs to the Mandelbrot set and is colored by a single color)","text":"<p>Consider .</p> <p>We will compute the first few iterations starting from :</p> <p> </p> <p> </p> <p>It appears that  converges to the same value and does not escape to infinity. For , the magnitude  does not exceed 2 in these iterations, so  is likely to be in the Mandelbrot set. In other words, these points do not escape to infinity, and their iterations remain bounded. These are typically colored by a single color.</p> <p></p> <p>Figure 4: Bounded region of the Mandelbrot set in complex plane coloured in black (source: Wikipedia).</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#example-2-a-number-that-does-not-iterate-a-lot-does-not-belong-to-the-mandelbrot-set-and-has-a-color-range","title":"Example 2: A Number that does not iterate a lot (does not belong to the Mandelbrot set and has a color range)","text":"<p>Consider .</p> <p>We will compute the iterations starting from :</p> <p>Here, , and at , , which is already greater than 2. The sequence diverges quickly. Therefore,  does not belong to the Mandelbrot set. These points are colored based on how quickly they escape to infinity. The color often represents the number of iterations it takes for  to exceed a certain threshold, which is set to 2.</p> <p></p> <p>Figure 5: Unbounded region of the set in the complex plane, with color shading representing the iteration count (source: Wikipedia).</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Introduction%20to%20the%20Mathematics%20of%20the%20Mandelbrot%20Set/#useful-terms-and-concepts","title":"Useful Terms and Concepts","text":"<p>To understand the Mandelbrot set and its computation, it's essential to grasp several key mathematical ideas. The terms outlined here can be explored further in references (Barnsley1988, Steeb2014, Kaye2008). Below is a brief introduction to the concepts required for understanding the set.</p> <p>The Mandelbrot set is an example of complex dynamics, which involves studying how the iterative function</p> <p> </p> <p>behaves when applied to complex numbers . The Mandelbrot set itself consists of all complex numbers  (which we compute in a grid) for which this iterative process does not cause values to grow infinitely large.</p> <p>A key term in this process is the escape radius. The escape radius helps determine whether a point  will eventually \"escape\" to infinity during iteration. Typically, an escape radius of 2 is used. If the magnitude of  exceeds this value, the point is considered to be escaping to infinity. This helps in deciding whether the corresponding complex number  is part of the Mandelbrot set.</p> <p>When visualizing the Mandelbrot set, two concepts are critical: iteration count and color mapping. The iteration count refers to how many iterations it takes for the magnitude of  to exceed the escape radius. This count forms the basis for color mapping, which assigns colors based on the number of iterations needed for escape. This technique visually reveals the Mandelbrot set's structure by illustrating the patterns that emerge as points escape at different rates.</p> <p>Another important concept is whether a sequence is bounded or unbounded. A bounded sequence remains within a certain distance from the origin, indicating that  is part of the Mandelbrot set. An unbounded sequence escapes to infinity, meaning  is not part of the set. The rate of escape provides insight into the set\u2019s intricate details.</p> <p>References</p> <ol> <li>Mandelbrot, B. B. (1980). The Fractal Geometry of Nature. New York: W.H. Freeman and Co.</li> <li>Scientific American. (1985). Fractals: The Patterns of Chaos. Scientific American.</li> <li>Barnsley, M. F. (1988). Fractals Everywhere. Academic Press, Inc.</li> <li>Steeb, W.-H. (2014). Nonlinear Dynamics and Chaos: Geometrical Methods. World Scientific Publishing.</li> <li>Kaye, M. (2008). Random Fractals: Theory and Applications. Springer.</li> </ol>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/","title":"Single-Threaded version","text":"<p>We start with the single-threaded version. This code executes the computation of the Mandelbrot set sequentially, processing each pixel one after the other without using concurrent execution or synchronization. This C++ code generates and saves a visualization of the Mandelbrot set for a given pixel grid (in this case ). The <code>computeMandelbrot</code> function iterates over each pixel, calculating how many iterations it takes for the complex function  to escape a defined boundary (magnitude greater than 2), storing the iteration counts in a vector.</p> <p>After we generate the Mandelbrot set, the <code>save_ppm</code> function writes the resulting iteration data to a PPM file, which enables us to visualize the set directly. We will cover each section of the code one by one, explaining the main tools and techniques used.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;//used to calculate time of execution\n#include &lt;thread&gt;// used later for multithreading\n\nconstexpr int X  = 1000;       // X  of the image (pixels)\nconstexpr int Y  = 1000;      // Y  of the image(pixels)\nconstexpr int MAX_ITER = 1000;   // Maximum number of iterations\n//This values are the constants according to the set (reference books)\nconstexpr double X_MIN = -2.0;   // Minimum x-axis value\nconstexpr double X_MAX = 1.0;    // Maximum x-axis value\nconstexpr double Y_MIN = -1.5;   // Minimum y-axis value\nconstexpr double Y_MAX = 1.5;    // Maximum y-axis value\n\n\n\n// Function to compute the Mandelbrot set\n    std::vector&lt;int&gt; computeMandelbrot() {\n    std::vector&lt;int&gt; iterations(X  * Y );\n\n// This corresponds to the chrono library. We start the execution time.\n    double total_scaling_time = 0.0;\n    double total_iteration_time = 0.0;\n\n// outer loops runs through each row y and the inner loop runs through each column x.\n    for (int y = 0; y &lt; Y ; ++y) {\n        for (int x = 0; x &lt; X ; ++x) {\n            auto start_scaling = std::chrono::high_resolution_clock::now();//start taking time\n            double real = X_MIN + (X_MAX - X_MIN) * x / (X  - 1);\n            double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y  - 1);\n\n            // creation of a complex number mapped into the pixel (x,y)\n            std::complex&lt;double&gt; c(real, imag);\n            // z starts from zero as defined by the algorithmus.\n            std::complex&lt;double&gt; z(0.0, 0.0);\n            auto end_scaling = std::chrono::high_resolution_clock::now();//stop taking time\n                        // display of the total time of this section\n            total_scaling_time += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_scaling - start_scaling).count() / 1e6;\n            // declaration of the iteration number: iter\n            int iter;\n            auto start_iteration = std::chrono::high_resolution_clock::now();//start taking time\n\n            for (iter = 0; iter &lt; MAX_ITER; ++iter) {\n                // the magnitude of z=2 is fixed.\n                if (std::abs(z) &gt; 2.0) break;\n\n                z = z * z + c;\n            }\n            auto end_iteration = std::chrono::high_resolution_clock::now();//stop taking time\n            // display of the total time of this section\n            total_iteration_time += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_iteration - start_iteration).count() / 1e6;\n\n\n            iterations[y * X  + x] = iter;\n        }\n    }\n    // Give the the total scaling and iteration time.\n    std::cout &lt;&lt; \"Total scaling time: \" &lt;&lt; total_scaling_time &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Total iteration time: \" &lt;&lt; total_iteration_time &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n    // Give the iterations counts for each pixel in the image.\n    return iterations;\n}\n\n// Function to save the Mandelbrot set to a PPM image file with gradient coloring.\nvoid save_ppm(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n    std::ofstream ofs(filename, std::ios::binary);\n\n    ofs &lt;&lt; \"P6\\n\" &lt;&lt; X  &lt;&lt; \" \" &lt;&lt; Y  &lt;&lt; \"\\n255\\n\";\n\n    for (int i = 0; i &lt; X  * Y ; ++i) {\n        int iter = iterations[i];\n        // Map iteration count to a color using a smooth gradient\n        unsigned char r = static_cast&lt;unsigned char&gt;(iter % 256);\n        unsigned char g = static_cast&lt;unsigned char&gt;((iter *2) % 256);\n        unsigned char b = static_cast&lt;unsigned char&gt;((iter *5) % 256);\n        ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b;\n    }\n\n    ofs.close();\n}\n\n\n\n// We call the function to compute the Mandelbrot set along with time measurements. Execution begins.\nint main() {\n\n    std::cout &lt;&lt; \"Width of the image:\" &lt;&lt; X &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Height of the image: \" &lt;&lt; Y &lt;&lt; std::endl;\n\n    auto start_compute = std::chrono::high_resolution_clock::now();\n    std::vector&lt;int&gt; iterations = computeMandelbrot();\n    auto end_compute = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_compute = end_compute - start_compute;\n    std::cout &lt;&lt; \"Total time taken to compute the Mandelbrot set (single-threaded version): \" &lt;&lt; elapsed_compute.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    int num_cpus = std::thread::hardware_concurrency();\n    std::cout &lt;&lt; \"Number of CPUs used: \" &lt;&lt; num_cpus &lt;&lt; std::endl;\n\n    auto start_save = std::chrono::high_resolution_clock::now();\n    //Save results\n    //We call the function to save iterations in PPM format.\n    save_ppm(iterations, \"mandelbrot_gradient.ppm\");\n    auto end_save = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_save = end_save - start_save;\n    std::cout &lt;&lt; \"Total time it takes to generate image: \" &lt;&lt; elapsed_save.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Mandelbrot set with colormap: mandelbrot_gradient.ppm\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#the-header","title":"The Header","text":"<p>We start by defining the header we introduce in the code. The specific commands in example snippets will be explained later in the next subsection in the body of the code. These are just examples to get you a feel of what the headers provide.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt; // Used to calculate execution time\n#include &lt;thread&gt; // Used later for multithreading\n</code></pre> <p>The <code>&lt;iostream&gt;</code> header manages standard input/output streams, like <code>std::cout</code> for printing to the console. Here is an example of the famous \"Hello, World!\".</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; // Outputs visible in the console\n    return 0;\n}\n</code></pre> <p>The <code>&lt;complex&gt;</code> header allows you to work with complex numbers, which is what we will need in this code. Complex numbers have both a real and an imaginary part. Here is an example where we create a complex number and display it.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n\nint main() {\n    std::complex&lt;double&gt; num(3.0, 4.0); // Create a complex number for example 3 + 4i\n    std::cout &lt;&lt; \"Real part: \" &lt;&lt; num.real() &lt;&lt; \", Imaginary part: \" &lt;&lt; num.imag() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#definition-of-constants","title":"Definition of constants","text":"<pre><code>constexpr int X  = 1000;      \nconstexpr int Y  = 1000;      \nconstexpr int MAX_ITER = 1000;   \nconstexpr double X_MIN = -2.0;   \nconstexpr double X_MAX = 1.0;    \nconstexpr double Y_MIN = -1.5;   \nconstexpr double Y_MAX = 1.5;    \n</code></pre> <p>The <code>constexpr</code> keyword is used to define variables, functions, and constructors that can be calculated when the code is compiled. This means the compiler finds their values while creating the program, not while it is running. This enables the compiler to make the code run faster.</p> <ul> <li><code>X</code> and <code>Y</code>: Define the dimensions of the output image in pixels, such as width and height.</li> <li><code>MAX_ITER</code>: The maximum number of iterations for checking the divergence of the sequence in the Mandelbrot formula.</li> <li><code>X_MIN</code>, <code>X_MAX</code>, <code>Y_MIN</code>, <code>Y_MAX</code>: Define the range of the complex plane to be visualized.</li> </ul> <p>This is a simple example of a code that you can compile and run with the defined constants.</p> <pre><code>#include &lt;iostream&gt;\n\nconstexpr int WIDTH = 640;\nconstexpr int HEIGHT = 480;\n\nint main() {\n    std::cout &lt;&lt; \"Image dimensions: \" &lt;&lt; WIDTH &lt;&lt; \"x\" &lt;&lt; HEIGHT &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#mandelbrot-set-computation-function","title":"Mandelbrot set computation function","text":"<p>This section contains the main function responsible for computing the Mandelbrot set once we have carried out the first steps introduced earlier. If you take a closer look, you will find the equation  from the Mandelbrot set definition defined earlier. To enable the computer to execute this equation and generate an image based on the number of iterations, we will use nested loops along with various <code>C++</code> features and commands.</p> <p>What we want to do here is to compute the Mandelbrot set by iterating over each pixel of a 2D image grid sized . For each pixel, we map its coordinates to a corresponding point in the complex plane. This involves scaling the pixel coordinates to fit within the specified range of the complex plane (from <code>X_MIN</code> to <code>X_MAX</code> for the real part and from <code>Y_MIN</code> to <code>Y_MAX</code> for the imaginary part). </p> <p>For each point in the complex plane, we then iterate the Mandelbrot formula:  starting from , and continue until either the magnitude of  exceeds 2 or the maximum number of iterations (<code>MAX_ITER</code>) is reached. The number of iterations required for the magnitude of  to exceed 2 is recorded for each pixel. The iteration counts for all pixels are stored in a vector and returned for further use, which will be used to generate the image.</p> <p>We are now showing this section of the code and will break down one-by-one the main tools and techniques used.</p> <p><pre><code>   std::vector&lt;int&gt; computeMandelbrot() {\n    std::vector&lt;int&gt; iterations(X  * Y );\n\n// This corresponds to the chrono library. We start the execution time.\n    double total_scaling_time = 0.0;\n    double total_iteration_time = 0.0;\n\n// outer loops runs through each row y and the inner loop runs through each column x.\n    for (int y = 0; y &lt; Y ; ++y) {\n        for (int x = 0; x &lt; X ; ++x) {\n            auto start_scaling = std::chrono::high_resolution_clock::now();//start taking time\n            double real = X_MIN + (X_MAX - X_MIN) * x / (X  - 1);\n            double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y  - 1);\n\n            // creation of a complex number mapped into the pixel (x,y)\n            std::complex&lt;double&gt; c(real, imag);\n            // z starts from zero as defined by the algorithmus.\n            std::complex&lt;double&gt; z(0.0, 0.0);\n            auto end_scaling = std::chrono::high_resolution_clock::now();//stop taking time\n                        // display of the total time of this section\n            total_scaling_time += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_scaling - start_scaling).count() / 1e6;\n            // declaration of the iteration number: iter\n            int iter;\n            auto start_iteration = std::chrono::high_resolution_clock::now();//start taking time\n\n            for (iter = 0; iter &lt; MAX_ITER; ++iter) {\n                // the magnitude of z=2 is fixed.\n                if (std::abs(z) &gt; 2.0) break;\n\n                z = z * z + c;\n            }\n            auto end_iteration = std::chrono::high_resolution_clock::now();//stop taking time\n            // display of the total time of this section\n            total_iteration_time += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_iteration - start_iteration).count() / 1e6;\n\n\n            iterations[y * X  + x] = iter;\n        }\n    }\n    // Give the the total scaling and iteration time.\n    std::cout &lt;&lt; \"Total scaling time: \" &lt;&lt; total_scaling_time &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Total iteration time: \" &lt;&lt; total_iteration_time &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n    // Give the iterations counts for each pixel in the image.\n    return iterations;\n}\n</code></pre> The main function definition: Let's start with the first section of the function.</p> <pre><code>std::vector&lt;int&gt; computeMandelbrot() {\n    // Body of the function  \n}\n</code></pre> <p><code>computeMandelbrot()</code> is function in which its main goal is to return a vector <code>std::vector&lt;int&gt;</code>, where the number of <code>iterations</code> for each pixel in the Mandelbrot set visualization to determine whether the corresponding point in the complex plane belongs to the Mandelbrot set will be stored. <code>std::vector&lt;int&gt;</code> dynamically allocates memory based on the image size (X * Y pixels). This is the main function that will be used by the caller directly without giving any further input in the parameters. For this reason, we use an empty <code>()</code>. At this point, this is all the information the caller will know and use. This is one of the main features of <code>C++</code> called encapsulation. All the further details will be handled inside the function.</p> <p>Initialisation and declaration of the variables:  Once we declared the function, we continue with the declaration of the local variables that we will use.</p> <pre><code>std::vector&lt;int&gt; computeMandelbrot() {\n    std::vector&lt;int&gt; iterations(X * Y);\n    // Body of the function\n    return iterations;\n}\n</code></pre> <p>The vector <code>iterations</code> is initialized and declared with a fixed size based on the dimensions . Using <code>std::vector</code> enables flexible, dynamic memory management, allowing the program to handle different image sizes without knowing the dimensions when you compile the code. Since every pixel in the image requires a corresponding iteration count, the vector <code>iterations</code> must have  elements to store the results. This ensures that the vector can hold exactly one value for each pixel in the image grid. After the entire Mandelbrot set has been computed and the <code>iterations</code> vector is filled with the iteration counts for all the pixels, <code>return iterations;</code> is executed, and the function sends the <code>iterations</code> vector back to the caller.</p> <p>Outer loop over y (image height) and inner Loop over x (image width): </p> <p>The main idea of the outer and inner loops is to iterate over every pixel in a 2D grid. The nested loop ensures that every pixel in the image is processed. Every <code>(x, y)</code> pair corresponds to a pixel in the image, which will be mapped to a complex number in the Mandelbrot domain of the set. <code>C++</code> is case sensitive, so note the difference between <code>x</code> and <code>X</code>.</p> <pre><code>for (int y = 0; y &lt; Y; ++y) {\n    for (int x = 0; x &lt; X; ++x) {\n        // Body of the function\n    }\n}\n</code></pre> <p>Here, <code>int y = 0; y &lt; Y; ++y</code> means the loop starts at <code>y = 0</code> (the first row) and increments <code>y</code> until it reaches <code>Y</code> (the total number of rows). The expression <code>++y</code> is the pre-increment operator. It increments the value of <code>y</code> by 1, then uses the updated value of <code>y</code> once the iteration loop is completed. It stops once <code>y == Y</code>. The same is valid for the inner loop using <code>x</code>. You can apply this straightforward loop configuration to all types of 2D grids or matrices to iterate over all the elements.</p> <p>Mapping image coordinates to complex plane: </p> <p>Inside the nested loop, the Mandelbrot set is defined in the complex plane, which is defined using <code>real</code> and <code>imag</code>. For this reason, what we do next inside the nested loop is to map the image pixel coordinates <code>(x, y)</code> to a point in the complex plane.</p> <p><pre><code>double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\ndouble imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n</code></pre> <code>x / (X - 1)</code> and <code>y / (Y - 1)</code> are used to normalize the pixel coordinates (<code>x</code>, <code>y</code>), mapping them to a range from 0 to 1.</p> <p>For example: When <code>x = 0</code>, <code>x / (X - 1)</code> becomes 0. When <code>x = X - 1</code> (the pixel at the right end), <code>x / (X - 1)</code> becomes 1. Exactly the same applies to <code>y</code>. The normalized values <code>x / (X - 1)</code> and <code>y / (Y - 1)</code> are scaled to the desired ranges. To perform this scaling, you take the normalized value and multiply it by the total range: <code>(X_MAX - X_MIN)</code> or <code>(Y_MAX - Y_MIN)</code>. After this is done, <code>X_MIN</code> or <code>Y_MIN</code> is added, respectively, to move the values to the correct location in the complex plane. Note that we use floating-point <code>double</code> precision to capture fine details.</p> <p>Creating complex number <code>c</code> and initializing <code>z</code>: </p> <p>In order to compute iterative formula of the Mandelbrot set, we need to define its components as follows.</p> <pre><code>std::complex&lt;double&gt; c(real, imag);\nstd::complex&lt;double&gt; z(0.0, 0.0);\n</code></pre> <p>where <code>c</code> is the complex number corresponding to the pixel (<code>x</code>, <code>y</code>). It is created using the previously calculated <code>real</code> and <code>imag</code> values. <code>z</code> is initialized to <code>0 + 0i</code> (the origin in the complex plane), as the formula indicates. Note that we use <code>std::complex&lt;double&gt;</code> which is a part of the C++ Standard Library, enabling us to represent and manipulate complex numbers.</p> <p>Initializing the iteration count and its loop: We initialize <code>iter</code> to track how many iterations it takes for the complex number to escape (if it makes it at all). This loop is a core part of generating the Mandelbrot fractal. The final value of <code>iter</code> tells us whether the point escapes quickly or stays within the set, allowing us to color the corresponding pixel accordingly.</p> <pre><code>int iter;\nfor (iter = 0; iter &lt; MAX_ITER; ++iter) {\n    if (std::abs(z) &gt; 2.0) break;\n    z = z * z + c;\n}\n</code></pre> <p>Following the same structure used previously in the nested loops, this is a loop that runs up to a maximum number of iterations (<code>MAX_ITER</code>), incrementing <code>iter</code> by 1 on each pass. The difference here, however, is that our loop has the condition <code>if (std::abs(z) &gt; 2.0) break;</code>. This condition checks if the magnitude (absolute value) of the complex number <code>z</code> has exceeded 2. This complex number is the Mandelbrot iteration formula <code>z = z * z + c;</code>. If the magnitude of <code>z</code> becomes larger than 2, we \"break\" out of the loop early (stop iterating) because the point is guaranteed to \"escape\" and is not part of the Mandelbrot set, and it gets assigned a color based on how fast it escapes. The value 2 is the threshold. Points that never escape (they reach <code>MAX_ITER</code>) are considered part of the Mandelbrot set and get a fixed color.</p> <p>Storing the iteration count in the vector: Outside of the iteration count loop, we proceed with storing the <code>iter</code> in the <code>iterations</code> vector defined at the beginning of this function.</p> <p><pre><code>iterations[y * X + x] = iter;\n</code></pre> We use this statement as a counter for each time that the code has to iterate over the pixel. This is a very useful and common technique to store the iterations in <code>1D</code> obtained from data in a grid. We need to work in one dimension because <code>std::vector&lt;int&gt;</code> is one-dimensional.</p> <p>The <code>return iterations;</code> statement is used to return the <code>iterations</code> vector from the function <code>computeMandelbrot</code>. This vector has the values we need to use as contour values in the image.</p> <p>The <code>&lt;chrono&gt;</code> library to measure computing time: The <code>chrono</code> library in <code>C++</code> is part of the standard library, and it is a tool that allows you to measure time intervals and manage durations in your programs. The following lines declare two variables, <code>total_scaling_time</code> and <code>total_iteration_time</code>, both of type <code>double</code>, and initialize them to <code>0.0</code>.</p> <p><pre><code>double total_scaling_time = 0.0;\ndouble total_iteration_time = 0.0;\n</code></pre> This indicates that these variables will be used to store floating-point numbers (they can  represent decimal values) which are used in the time measurement. Inside the nested loops,  these lines are used to measure the execution time of the section responsible for scaling pixel coordinates to the complex plane.</p> <pre><code>auto start_scaling = std::chrono::high_resolution_clock::now(); // start taking time\n// Body of the scaling section\nauto end_scaling = std::chrono::high_resolution_clock::now();   // stop taking time\n</code></pre> <p>The <code>std::chrono::high_resolution_clock</code> is part of the <code>chrono</code> library and provides a high-resolution timer. The <code>auto</code> keyword lets the compiler figure out the type of a variable based on what you assign to it. Here, <code>start_scaling</code> and <code>end_scaling</code> will be of type <code>std::chrono::high_resolution_clock::time_point</code>, which is used to represent a specific moment in time.</p> <p>The following line serves to calculate the overall duration of the scaling and accumulates this time in <code>total_scaling_time</code>.</p> <p><pre><code>total_scaling_time += std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_scaling - start_scaling).count() / 1e6;\n</code></pre> This part calculates the elapsed time between two points in the program: <code>start_scaling</code> and <code>end_scaling</code>. Both <code>start_scaling</code> and <code>end_scaling</code> are of type <code>std::chrono::high_resolution_clock::time_point</code>, which represents a point in time. The result of this subtraction is a <code>std::chrono::duration</code>. The <code>duration_cast</code> function converts the calculated duration into a specific duration type\u2014in this case, microseconds (<code>std::chrono::microseconds</code>). The <code>count()</code> method gets the number that represents the duration in microseconds. To display the results in seconds, we need, however, to divide it by <code>1e6</code>. Finally, the result from the above calculations (the time in seconds) is added to the variable <code>total_scaling_time</code>. Note that the operator <code>+=</code> in the expression is used for accumulating values, which is equivalent to this:</p> <p><pre><code>total_scaling_time = total_scaling_time + (calculated_time);\n</code></pre> Outside of the nested loop, this measure is display as follows, <pre><code>std::cout &lt;&lt; \"Total scaling time: \" &lt;&lt; total_scaling_time &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n</code></pre> Exactly the same procedure is repeated in the iteration section.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#saving-to-ppm-image-function","title":"Saving to PPM (image) function","text":"<p>The function <code>save_ppm</code> is responsible for saving the results of the Mandelbrot set computation to a PPM (Portable Pixmap) image file with gradient coloring. We use this format because it does not require any additional installation (unlike PNG, JPG, and others).</p> <pre><code>void saveToPPM(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n    std::ofstream ofs(filename, std::ios::binary);\n\n    ofs &lt;&lt; \"P6\\n\" &lt;&lt; X  &lt;&lt; \" \" &lt;&lt; Y  &lt;&lt; \"\\n255\\n\";\n\n    for (int i = 0; i &lt; X  * Y ; ++i) {\n        int iter = iterations[i];\n        // Map iteration count to a color using a smooth gradient\n        unsigned char r = static_cast&lt;unsigned char&gt;(iter % 256);\n        unsigned char g = static_cast&lt;unsigned char&gt;((iter *2) % 256);\n        unsigned char b = static_cast&lt;unsigned char&gt;((iter *5) % 256);\n        ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b;\n    }\n\n    ofs.close();\n}\n</code></pre> <p>Function and input Parameters: The return type <code>void</code> indicates that this function does not return any value. What we want to do here is an action (saving an image) without providing any data back to the caller; for this reason, it is the appropriate option.</p> <pre><code>void save_ppm(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n        // Body of the function\n}\n</code></pre> <p>The parameter <code>const std::vector&lt;int&gt;&amp; iterations</code> inside the function represents the data to be saved, specifically a vector (<code>std::vector&lt;int&gt;</code>) of iteration counts for each pixel in the Mandelbrot set. It is passed by constant reference (<code>const &amp;</code>). This means that <code>const</code> indicates that the data inside the vector cannot be modified by the function and <code>&amp;</code> (reference) means that instead of passing a copy of the vector, a reference is passed, avoiding unnecessary duplication and saving memory, reducing overhead. What we mean by overhead is the additional computations, allocations, or operations that do not contribute directly to the primary functionality of the code, affecting performance and efficiency.</p> <p>The parameter <code>const std::string&amp; filename</code> represents the name of the file to which the Mandelbrot set image will be saved. Note that including <code>filename</code> makes it clear what the function is intended to do. Also, if you were to pass the filename as a regular <code>std::string</code> (by value without the <code>&amp;</code>), the function would make a copy of that string; for this reason, we keep passing by reference as well.</p> <p>Opening the output file: Once we go inside the function, <code>std::ofstream ofs</code> creates a file stream to write data to the specified file which in this case is <code>filename</code>. The flag <code>std::ios::binary</code> opens the file in binary mode and ensures the data is written in raw binary format, which is important for image files.</p> <pre><code>std::ofstream ofs(filename, std::ios::binary);\n</code></pre> <p><code>std::ofstream</code> stands for output file stream, which is a class in the <code>&lt;fstream&gt;</code> library designed to handle writing to files. <code>ofs</code> is the name of the <code>std::ofstream</code> object we are creating. The binary mode of <code>std::ios::binary</code> is important here. For an image file like a PPM file (which contains pixel data), you don't want any translation; what you want is the exact binary data written to the file. The default option is text mode, and this might convert certain characters to make them more readable or conform to your specific platform.</p> <p>Writing the PPM header: The main purpose of the following line is to write the header of a PPM image file in the P6 format. The header is a block of metadata (format type, dimensions, color range) placed at the beginning of a file that contains important information about the file's contents. The PPM format supports two variations: P3 (ASCII mode) and P6 (binary mode). P6 format stores the pixel data in binary, making it compact and efficient to read/write.</p> <pre><code> ofs &lt;&lt; \"P6\\n\" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \"\\n255\\n\";\n</code></pre> <p>Here, <code>ofs &lt;&lt; \"P6\\n\"</code> writes the string <code>\"P6\\n\"</code> to the file stream <code>ofs</code>. <code>\"P6\"</code> specifies that the file format is PPM in binary mode. <code>\\n</code> represents a newline character. This ensures that each part of the header appears on its own line as required by the PPM format specification.</p> <p><code>ofs &lt;&lt; \"P6\\n\" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \"\\n255\\n\"</code> writes the image dimensions (width and height) to the file. <code>ofs &lt;&lt; \"\\n255\\n\"</code> specifies the maximum color value, 255, for 8-bit color channels. An example of the P6 format header containing these three specifications can be shown as follows:</p> <pre><code>P6\n5000 5000\n255\n</code></pre> <p>Writing the pixel data and closing: </p> <p>This section of the code is responsible for writing the computed set to an image file (in PPM format). The following loop transforms the computed iteration counts into color values (red, green, and blue components) for each pixel. </p> <pre><code>    for (int i = 0; i &lt; X  * Y ; ++i) {\n        int iter = iterations[i];\n        unsigned char r = static_cast&lt;unsigned char&gt;(iter % 256);\n        unsigned char g = static_cast&lt;unsigned char&gt;((iter *2) % 256);\n        unsigned char b = static_cast&lt;unsigned char&gt;((iter *5) % 256);\n        ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b;\n    }\n    ofs.close();\n</code></pre> <p><code>for (int i = 0; i &lt; X * Y; ++i)</code> is a for loop that iterates over every pixel in the image. The image has <code>X * Y</code> pixels, where <code>X</code> is the width and <code>Y</code> is the height. <code>i</code> is the loop counter, running from <code>0</code> to <code>X * Y - 1</code> (inclusive). The choice of <code>X * Y - 1</code> ensures that the loop correctly iterates through all pixel indices in a zero-based indexing system.</p> <p><code>int iter = iterations[i];</code>: Here, <code>iter</code> is the number of iterations (from the Mandelbrot computation) for the pixel at position <code>i</code>. <code>iterations</code> is a vector that stores the iteration count for every pixel, so <code>iterations[i]</code> gives the number of iterations required for the pixel at position <code>i</code> to either converge or diverge. Note that we have given the same name <code>iter</code>. While we have used this name before in <code>computeMandelbrot()</code>, they exist in different contexts. The one in <code>computeMandelbrot()</code> counts the iterations during the computation of the Mandelbrot set, while the one in <code>save_ppm()</code> retrieves the precomputed iteration count to create an image.</p> <p>This line of code calculates the red (r) component of a color based on the iteration count. <code>iter % 256</code> takes the iteration count <code>iter</code> and applies the modulo operator. It ensures that the resulting value is within the range of 0 to 255. This is important because RGB color channels can only represent values within this range. The result of <code>iter % 256</code> is then converted to an <code>unsigned char</code>. An <code>unsigned char</code> is an 8-bit integer type that can store values from 0 to 255. <pre><code>        unsigned char r = static_cast&lt;unsigned char&gt;(iter % 256);\n</code></pre></p> <p>This line calculates the green (g) component of the color by first multiplying <code>iter</code> by 2. The result is then taken modulo 256, ensuring that the value remains within the range of 0 to 255. This is important because the green color component must fit within this range to be valid for RGB representation in image files.</p> <pre><code>        unsigned char g = static_cast&lt;unsigned char&gt;((iter *2) % 256);\n</code></pre> <p>This line calculates the blue (b) component of the color by multiplying <code>iter</code> by 5 and then taking the result modulo 256. By using different multipliers (1 for red, 2 for green, and 5 for blue), the red, green and blue components are assigned different patterns of intensity. This creates a gradient effect in the final image.</p> <pre><code>        unsigned char b = static_cast&lt;unsigned char&gt;((iter *5) % 256);\n</code></pre> <p><code>ofs &lt;&lt; r &lt;&lt; g &lt;&lt; b;</code>: <code>ofs</code> is the output file stream (an <code>std::ofstream</code> object) that was opened to write binary data to the PPM image file. This line writes the red (<code>r</code>), green (<code>g</code>), and blue (<code>b</code>) color values for the current pixel to the file. Each pixel in the image is represented by three consecutive bytes: one for red, one for green, and one for blue. This line outputs those bytes in binary format.</p> <p>Once the loop finishes writing all the pixel data, the file stream is closed with <code>ofs.close();</code>. This ensures that all data is properly written to the file and the file is saved correctly. If this is not done, some of this data might not be written, leading to a corrupted or incomplete file, and the file might not be readable by other programs.</p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#the-caller-function","title":"The caller function","text":"<p>The caller function in C++ serves as the entry point for any program. It is where the execution starts and where the tasks are managed. The <code>main</code> function is the designated entry point for any <code>C++</code> program.</p> <pre><code>int main() {\n\n    std::cout &lt;&lt; \"Width of the image:\" &lt;&lt; X &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Height of the image: \" &lt;&lt; Y &lt;&lt; std::endl;\n\n    auto start_compute = std::chrono::high_resolution_clock::now();\n    std::vector&lt;int&gt; iterations = computeMandelbrot();\n    auto end_compute = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_compute = end_compute - start_compute;\n    std::cout &lt;&lt; \"Total time taken to compute the Mandelbrot set (single-threaded version): \" &lt;&lt; elapsed_compute.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    int num_cpus = std::thread::hardware_concurrency();\n    std::cout &lt;&lt; \"Number of CPUs used: \" &lt;&lt; num_cpus &lt;&lt; std::endl;\n\n    auto start_save = std::chrono::high_resolution_clock::now();\n    saveToPPM(iterations, \"mandelbrot_gradient.ppm\");\n    auto end_save = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; elapsed_save = end_save - start_save;\n    std::cout &lt;&lt; \"Time it takes to generate image:  \" &lt;&lt; elapsed_save.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Mandelbrot set with colormap: mandelbrot_gradient.ppm\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>In <code>C++</code>, the name <code>main</code> cannot be changed. The return type <code>int</code> indicates that this function returns an integer value, which is 0 for successful execution.</p> <pre><code>int main() {\n    // List of execution orders\n    return 0;\n}      \n</code></pre> <p>Calling <code>computeMandelbrot()</code>: This line calls the function <code>computeMandelbrot()</code> and stores the returned vector of integers in the <code>iterations</code> variable.</p> <pre><code>std::vector&lt;int&gt; iterations = computeMandelbrot();\n</code></pre> <p>Saving the results: Once <code>computeMandelbrot()</code> is executed, <code>save_ppm(iterations, \"mandelbrot_gradient.ppm\");</code> calls the <code>save_ppm</code> function, which takes the computed iterations and saves them in a PPM file format.</p> <pre><code>save_ppm(iterations, \"mandelbrot_gradient.ppm\");\n</code></pre> <p>Display dimensions, number of CPUs, output/confirmation messages and exit: Display messages are important because the user of the code will have different requirements, and when the code is run, it is useful to read in the console the case that you are running. In this code, the dimensions of the image or grid are displayed as follows:</p> <pre><code>std::cout &lt;&lt; \"Width of the image:\" &lt;&lt; X &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Height of the image: \" &lt;&lt; Y &lt;&lt; std::endl;\n</code></pre> <p><code>Y</code>, which represents the width and height of the image, is printed along with descriptive text. <code>std::endl</code> adds a newline and ensures the output is shown immediately.</p> <p>The following line informs the user how many CPU cores are detected.  <pre><code>int num_cpus = std::thread::hardware_concurrency();\nstd::cout &lt;&lt; \"Number of CPUs used: \" &lt;&lt; num_cpus &lt;&lt; std::endl;\n</code></pre></p> <p><code>std::thread::hardware_concurrency()</code> returns the number of threads the hardware supports. We will use <code>std::thread</code> extensively in the following section on Multithreading and Parallelism.</p> <p>It is always good practice to output a message indicating that the code has run correctly. You will know that your code has no runtime issues up to this point if the message is displayed.</p> <pre><code>std::cout &lt;&lt; \"Mandelbrot set with colormap: mandelbrot_gradient.ppm\" &lt;&lt; std::endl;\n</code></pre> <p>Timing the <code>computeMandelbrot()</code> and the saving of results</p> <p>We measure in this function too the execution time here and obtain output in the console. This first and second group of lines measures the time taken to compute and save the computed Mandelbrot set to a file, respectiveley.</p> <p><pre><code>auto start_compute = std::chrono::high_resolution_clock::now();\nstd::vector&lt;int&gt; iterations = computeMandelbrot();\nauto end_compute = std::chrono::high_resolution_clock::now();\nstd::chrono::duration&lt;double&gt; elapsed_compute = end_compute - start_compute;\nstd::cout &lt;&lt; \"Total time taken to compute the Mandelbrot set (single-threaded version): \" &lt;&lt; elapsed_compute.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n</code></pre> <pre><code>auto start_save = std::chrono::high_resolution_clock::now();\nsaveToPPM(iterations, \"mandelbrot_gradient.ppm\");\nauto end_save = std::chrono::high_resolution_clock::now();\nstd::chrono::duration&lt;double&gt; elapsed_save = end_save - start_save;\nstd::cout &lt;&lt; \"Total time it takes to generate image: \" &lt;&lt; elapsed_save.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n</code></pre></p>"},{"location":"The%20main%20Mandelbrot%20set%20calculation/Main%20Code/#the-output","title":"The output","text":"<p>We compile the code as follows. <pre><code> g++ -std=c++11 -o mandelbrot mandelbrot_set_exploration_main_code_general_single_threaded.cpp -pthread\n</code></pre> Execute the command <pre><code> ./mandelbrot\n</code></pre></p> <p>Here, we print-out the total time spent on scaling coordinates and performing iterations. <pre><code>Width of the image:5000\nHeight of the image: 5000\nTotal scaling time: 0.007769 seconds\nTotal iteration time: 275.241 seconds\nTotal time taken to compute the Mandelbrot set (single-threaded version): 288.617 seconds\nNumber of CPUs used: 12\nTotal time it takes to generate image: 6.57477 seconds\nMandelbrot set with colormap: mandelbrot_gradient.ppm\n</code></pre></p> <p>The following image corresponds to the output file.</p> <p></p> <p>Figure: Mandelbrot set output.</p> <p>Below is a zoomed-in section of the image using ParaView which we will cover in the following section.</p> <p></p> <p>Figure: Zommed-in section of the Mandelbrot set using ParaView.</p>"},{"location":"Visualization%20Techniques/3D%20Data%20creation%20%28extrusion%29/","title":"3D Data creation (extrusion)","text":"<p>Likewise, in the multithreaded version of our code, <code>saveToVTK3D</code> converts the 2D Mandelbrot set into a 3D representation and saves it in a VTK file format. This file can be used by visualization tools to render a 3D view of the Mandelbrot set. The function takes the <code>iterations</code> vector for each point in the 2D Mandelbrot set and \"extrudes\" (projects) it along a third dimension (Z-axis) based on these iteration values. To do this, we map the iteration count to a height (Z-coordinate) using logarithmic scaling to create a smoother extrusion. The function writes this 3D data to the file using the structured grid format of VTK.</p> <pre><code>void saveToVTK3D(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n    std::ofstream ofs(filename);\n\n    ofs &lt;&lt; \"# vtk DataFile Version 3.0\\n\";\n    ofs &lt;&lt; \"3D Mandelbrot Set\\n\";\n    ofs &lt;&lt; \"ASCII\\n\";\n    ofs &lt;&lt; \"DATASET STRUCTURED_GRID\\n\";\n    ofs &lt;&lt; \"DIMENSIONS \" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \" \" &lt;&lt; Z &lt;&lt; \"\\n\";\n    ofs &lt;&lt; \"POINTS \" &lt;&lt; X * Y * Z &lt;&lt; \" float\\n\";\n\n    // Generate 3D points by extruding along the Z-axis, with smoother scaling\n    for (int z = 0; z &lt; Z; ++z) {\n        for (int y = 0; y &lt; Y; ++y) {\n            for (int x = 0; x &lt; X; ++x) {\n                double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\n                double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n\n                // Normalize iteration count between 0 and 1\n                double normalized_iter = static_cast&lt;double&gt;(iterations[y * X + x]) / MAX_ITER;\n\n                // Logarithmic scaling for smoother extrusion\n                double z_coord = SCALING_FACTOR * log(1 + normalized_iter * (Z - 1));\n\n                ofs &lt;&lt; real &lt;&lt; \" \" &lt;&lt; imag &lt;&lt; \" \" &lt;&lt; z_coord &lt;&lt; \"\\n\";\n            }\n        }\n    }\n\n    ofs &lt;&lt; \"\\nPOINT_DATA \" &lt;&lt; X * Y * Z &lt;&lt; \"\\n\";\n    ofs &lt;&lt; \"SCALARS mandelbrot_iterations int 1\\n\";\n    ofs &lt;&lt; \"LOOKUP_TABLE default\\n\";\n\n    // Fill the scalar values for the 3D points\n    for (int z = 0; z &lt; Z; ++z) {\n        for (int y = 0; y &lt; Y; ++y) {\n            for (int x = 0; x &lt; X; ++x) {\n                ofs &lt;&lt; iterations[y * X + x] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n\n    ofs.close();\n}\n</code></pre> <p>Function description, input parameters and file opening/closing: Here, with the exception of the name <code>saveToVTK3D</code>, everything is similar to the 2D grid version.</p> <p>We use this time <code>ofs &lt;&lt; \"3D Mandelbrot Set\\n\";</code>. Note that <code>ofs &lt;&lt; \"DIMENSIONS \" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \" \" &lt;&lt; Z &lt;&lt; \"\\n\";</code>, we include this time <code>Z</code> to represent the number of points along the z-axis in the 3D grid. This new line <code>ofs &lt;&lt; \"POINTS \" &lt;&lt; X * Y * Z &lt;&lt; \" float\\n\";</code> specifies the total number of points in the dataset and indicates that these points are of type <code>float</code>. The total number of points is the product of the dimensions . ParaView will know how many entries to read when loading the point data. When handling 3D data, it is recommended to use real-number values that can include decimal points for accurately mapping complex coordinates in a continuous space. </p> <p>3D generation loop by extrusion: We need to generate the 3D grid in order to fill it later with the <code>iterations</code> vector. We now have a triple nested loop that generates 3D coordinates for every point in the grid. It iterates through each point in the defined grid based on the dimensions , , and . The outer loop in the z-direction represents the extrusion dimension (Z), which refers to the depth or height in the 3D visualization.  </p> <pre><code>    for (int z = 0; z &lt; Z; ++z) {\n        for (int y = 0; y &lt; Y; ++y) {\n            for (int x = 0; x &lt; X; ++x) {\n                double real = X_MIN + (X_MAX - X_MIN) * x / (X - 1);\n                double imag = Y_MIN + (Y_MAX - Y_MIN) * y / (Y - 1);\n\n                // Normalize iteration count between 0 and 1\n                double normalized_iter = static_cast&lt;double&gt;(iterations[y * X + x]) / MAX_ITER;\n\n                // Logarithmic scaling for smoother extrusion\n                double z_coord = SCALING_FACTOR * log(1 + normalized_iter * (Z - 1));\n\n                ofs &lt;&lt; real &lt;&lt; \" \" &lt;&lt; imag &lt;&lt; \" \" &lt;&lt; z_coord &lt;&lt; \"\\n\";\n            }\n        }\n    }\n</code></pre> <p>For each combination of indices , , and , it calculates the corresponding real and imaginary parts of the complex number based on the position of the pixel, mapping pixel coordinates to values in the complex plane.</p> <p>The code normalizes the iteration count from the iterations vector for each  point to a range between 0 and 1. To create smoother transitions in the 3D extrusion, logarithmic scaling is applied to the normalized iteration count. This scaled value is then used to determine the -coordinate for each point in 3D space.</p> <p>Note that to use <code>SCALING_FACTOR</code>, we need to add this to the definition of constants. We need this scaling; otherwise, the z-direction of the 3D output will be many orders of magnitude higher than the dimensions of the , making it very difficult to post-process.</p> <pre><code>constexpr double SCALING\\_FACTOR = 0.1;\n</code></pre> <p>The computed coordinates (real, imag, z) are output to the VTK file. This is the main 3D structure.</p> <p>Data specification of 3D points: The following lines are the same as in the 2D grid case, with the only difference being that <code>POINT_DATA:</code> gets the number of points with , corresponding to the total number of points in the 3D grid.</p> <pre><code>    ofs &lt;&lt; \"\\nPOINT_DATA \" &lt;&lt; X * Y * Z &lt;&lt; \"\\n\";\n    ofs &lt;&lt; \"SCALARS mandelbrot_iterations int 1\\n\";\n    ofs &lt;&lt; \"LOOKUP_TABLE default\\n\";\n</code></pre> <p>Loop to fill scalar values for the 3D points: We finally write the iteration counts for each  point in the 2D grid for every extruded layer along the z-axis.</p> <pre><code>    for (int z = 0; z &lt; Z; ++z) {\n        for (int y = 0; y &lt; Y; ++y) {\n            for (int x = 0; x &lt; X; ++x) {\n                ofs &lt;&lt; iterations[y * X + x] &lt;&lt; \"\\n\";\n            }\n        }\n    }\n</code></pre> <p>Checking the output:</p> <p>Likewise, once you have done this a <code>.vtk</code> would have been created and when you open the file with VIM. <pre><code>vim mandelbrot_3d_smooth.vtk\n</code></pre> The follow type of output should come. This is just an extraction of the file.</p> <p><pre><code> vtk DataFile Version 3.0\n3D Mandelbrot Set\nASCII\nDATASET STRUCTURED_GRID\nDIMENSIONS 1000 1000 100\nPOINTS 100000000 float\n-2 -1.5 0.00944007\n-1.997 -1.5 0.00944007\n-1.99399 -1.5 0.00944007\n-1.99099 -1.5 0.00944007\n-1.98799 -1.5 0.00944007\n-1.98498 -1.5 0.00944007\n-1.98198 -1.5 0.00944007\n-1.97898 -1.5 0.00944007\n-1.97598 -1.5 0.00944007\n-1.97297 -1.5 0.00944007\n-1.96997 -1.5 0.00944007\n-1.96697 -1.5 0.00944007\n-1.96396 -1.5 0.00944007\n-1.96096 -1.5 0.00944007\n-1.95796 -1.5 0.00944007\n-1.95495 -1.5 0.00944007\n// Rest of the file\n</code></pre> Remember that a 3D output needs the x,y coordinates to fully define the spatial relationships of the points as compared to the 2D output presented earlier. After the <code>POINTS</code> section, you would typically have the <code>POINT_DATA</code> section followed by the scalar values associated with each point and should look like this.  <pre><code>POINT_DATA 100000000\nSCALARS mandelbrot_iterations int 1\nLOOKUP_TABLE default\n0\n1\n2\n// Rest of the file\n</code></pre></p>"},{"location":"Visualization%20Techniques/Rendering%20techniques%20for%20scientific%20visualization/","title":"Rendering techniques for scientific visualization","text":"<p>Our starting point is working with VTK in 3D. The development of this code was done on a workstation with 64GB of RAM. This allows us to post-processes with a high level of fidelity. If you are using a laptop, it is recommended to limit the grid dimensions to 500x500.</p> <p>Opening the file and view settings: Start ParaView and load your <code>.vtk</code> file via <code>File &gt; Open</code>. You will see the following graphical user interface.</p> <p>The graphical user interface (GUI) of ParaView is designed to facilitate visualization and analysis of scientific data. Here\u2019s an overview of the key components, focusing on three main areas: Pipeline Browser, Color Map Editor, and Properties Panel.</p> <ol> <li> <p>The Pipeline Browser is a crucial part of interface that displays the data pipeline, showing all the loaded datasets and the filters applied to them. It presents a hierarchical view of all sources (datasets) and filters applied, allowing users to visualize the flow of data processing. You can toggle the visibility (the eye icon) of individual elements in the pipeline, allowing you to focus on specific datasets or results.</p> </li> <li> <p>The Color Map Editor is used to customize how data is visually represented through different color mappings.</p> </li> <li> <p>The Properties Panel is where users configure the settings and parameters for the selected dataset or filter. This is the place where you can tune the different parameters to obtain a nice visualization. We will use this in the rendering.</p> </li> </ol> <p>To obtain the following figure, select <code>Surface with edges</code> in the toolbar. We have applied here a colormap (coming next).</p> <p></p> <p>Figure: ParaView GUI.</p> <p>Extract surface: A very important step. For certain analysis, like rendering only the outer surface is important. By extracting the surface we reduce the data size, making rendering faster and more efficient. </p> <ul> <li>Make sure the vtk file is selected in the pipeline browser. Go to <code>Filters &gt; Alphabetical &gt; Extract Surface</code> or search for <code>Extract Surface</code> in the filters toolbar.</li> <li>Apply the filter by clicking the Apply button in the Properties panel.</li> </ul> <p></p> <p>Figure: Extract surface option in ParaView.</p> <p>Color settings: In the colormap editor, to open the color options select the <code>Choose prest</code> (option number 6 going downwards).</p> <p></p> <p>Figure: Colormap options.</p> <p>You will be able to choose the most adequate colormap as shown below.</p> <p></p> <p>Figure: Colormap palette.</p> <p>An important option is the <code>Rescale to custom range</code> (option number 2 going downwards). Particularly in visualizations with a vast range of values when you want to focus on small section you can select the values of range of values and the colormap will be adapted accordingly.</p> <p>In our case, eventhough the iterations go beyond 50, we chose this limit as it shows better the nuances in the locations near the bulb edges.</p> <p></p> <p>Figure: Rescale to custom range.</p> <p>Export as a high quality figure: ParaView offers the option to save a screenshot in very good resolution. To do this go to <code>File &gt; Save Screenshot</code>. Once you click you will see the following window.</p> <p></p> <p>Figure: Save screenshot options.</p> <p>You can increase the resolution however it is very easy to increase the size by doing so. </p> <p>Rendering options: In this section, we are going to use now a high resolution 3D file obtained with 1000x1000 pixels. The following figure was generated with the following configuration that you can apply to your 3D file and explore further:</p> <p></p> <p>Figure: Settings used after extracting the surface.</p> <p>We are using a slight level of transparency and this enable us to see inside the black region. Note that we see in full display the finer details of the set. </p> <p></p> <p>Figure: Mandelbrot set in ParaView.</p> <p>Another feature is the level of specular used. Due to the high resolution is not visible however in the following figure at a lower resolution you can see the \"brightness\".</p> <p></p> <p>Figure: A higher specular level.</p> <p>The Smooth filter in ParaView is used to smooth the surface of a mesh or geometry. This option reducing sharp edges, noise, or roughness in the data. It is particular useful in data set with lower resolution. The following figure was generate with the following configuration:</p> <p></p> <p>Figure: Settings used inside the smooth filter.</p> <p>Note the use of transparency (opacity option) and that the finer details are now a bit blurry.</p> <p></p> <p>Figure: Mandelbrot set in ParaView where the smooth filter was applied.</p>"},{"location":"Visualization%20Techniques/The%20ParaView%20format/","title":"The ParaView format","text":"<p>In this section, we will show how to output our image in <code>.vtk</code> format, which will allow us to access powerful options for scientific visualization. For this purpose, we will use our multithreaded version. Due to the modularity of <code>C++</code>, the only function we need to modify is <code>save_ppm</code>, which will be replaced by <code>save_vtk</code>.</p> <p>An important reference that I recommend, in addition to the useful information available in the Kitware community forums, is the works by (William), the founders of Kitware, where you can learn more about the graphics pipeline.</p> <p>References</p> <ol> <li>William J.. Schroeder, Ken Martin, and Bill Lorensen. The Visualization Toolkit: An Object-Oriented Approach to 3D Graphics. Kitware., 2006.</li> </ol>"},{"location":"Visualization%20Techniques/The%20ParaView%20format/#saving-to-vtk-format-function-in-2d","title":"Saving to VTK format function in 2D","text":"<p>In the multithreaded version of our code, the <code>save_vtk</code> function writes the Mandelbrot set data into a VTK file for visualization. The header includes the metadata such as the file version, description, and format (ASCII in this case). It then defines the data structure (<code>STRUCTURED_POINTS</code>), specifying the dimensions of the grid. After that, this function writes the scalar field for the points (<code>iterations</code> vector). This enables tools like ParaView to process the image.</p> <pre><code>void save_vtk(const std::vector&lt;int&gt;&amp; iterations, const std::string&amp; filename) {\n    std::ofstream ofs(filename);\n\n    ofs &lt;&lt; \"# vtk DataFile Version 3.0\\n\";\n    ofs &lt;&lt; \"Mandelbrot Set\\n\";\n    ofs &lt;&lt; \"ASCII\\n\";\n    ofs &lt;&lt; \"DATASET STRUCTURED_POINTS\\n\";\n    ofs &lt;&lt; \"DIMENSIONS \" &lt;&lt; X &lt;&lt; \" \" &lt;&lt; Y &lt;&lt; \" 1\\n\";\n    ofs &lt;&lt; \"ORIGIN 0 0 0\\n\";\n    ofs &lt;&lt; \"SPACING 1 1 1\\n\";\n    ofs &lt;&lt; \"POINT_DATA \" &lt;&lt; X * Y &lt;&lt; \"\\n\";\n    ofs &lt;&lt; \"SCALARS mandelbrot_iterations int 1\\n\";\n    ofs &lt;&lt; \"LOOKUP_TABLE default\\n\";\n\n    for (int i = 0; i &lt; X * Y; ++i) {\n        ofs &lt;&lt; iterations[i] &lt;&lt; \"\\n\";\n    }\n\n    ofs.close();\n}\n\\end{lstlisting}\n</code></pre> <p>Function description, input parameters and file opening/closing: What this function does is to transfer the Mandelbrot set data (<code>iterations</code> vector) to a VTK file. It has exactly the same inputs as <code>save_ppm</code>.</p> <p>As with the previous PPM format, we need to open the file with <code>std::ofstream</code>. This is what enables the program to export the data from memory to a usable file format. Without this, the program would be unable to save or share the results. <code>std::ofstream ofs(filename);</code> creates an output file stream (<code>ofs</code>) and opens the file named <code>filename</code> for writing. Once the function has completed its tasks, it is good practice to include <code>ofs.close();</code> to close the file after all the data has been written.</p> <p>VTK header and dataset description: Following this, we need to define the basic metadata required by VTK files; otherwise, ParaView would not be able to operate with our output. It is important to know that the VTK file format has a specific order that must be followed so ParaView (or any other compatible VTK-based applications) can read the file correctly.</p> <p>As we previously mentioned, <code>ofs</code> is an output file stream object of type <code>std::ofstream</code> used to write data to a file. The <code>&lt;&lt;</code> (data is sent in this direction) operator is the stream insertion operator that sends data to the output stream for writing. <code>&lt;&lt; \"\\n\"</code> is used to insert a newline. <code>ofs &lt;&lt; \"\\# vtk DataFile Version 3.0\\n\";</code> tells ParaView that this is a VTK file version 3.0. Different versions of VTK may use different syntax or handle data differently. <code>ofs &lt;&lt; \"Mandelbrot Set\\n\";</code> is a title that explains that this file contains Mandelbrot set data. It is a helpful to use it as identification. <code>ofs &lt;&lt; \"ASCII\\n\";</code> is needed to store the data in a readable text format (ASCII), not binary. The fact that ASCII is a human-readable format means that the data can be seen, verified, and modified in a text editor like <code>VIM</code> or <code>emacs</code>. The option <code>ofs &lt;&lt; \"DATASET STRUCTURED_GRID\\n\";</code> enables us to use a structured grid that represents data where points are organized in a regular grid layout (a 2D grid).</p> <p>Grid dimensions, origin and spacing: We continue with more specifications.</p> <p><code>ORIGIN 0 0 0:</code> sets the origin of the grid at the point (0, 0, 0) in 3D space. This is important for the software to know where to place the first point of the dataset. <code>SPACING 1 1 1:</code> This indicates that each point in the grid is spaced 1 unit apart in the x, y, and z directions. For a 2D grid, the z spacing is not relevant but we keep it to maintain the compatibility of the data format.</p> <p>Point data specification: <code>POINT_DATA X * Y:</code> indicates that the grid contains  points, with each point representing a pixel in the image. This is important for memory allocation. <code>POINT_DATA</code> is part of the syntax in ASCII file format in VTK. Other keywords include <code>SCALARS</code>, <code>VECTORS</code>, <code>CELL_DATA</code>, and have different purposes. For example, in <code>SCALARS mandelbrot_iterations int 1:</code>, each point in the grid has a scalar value for the iterations. The data type is <code>int</code> (integer) which is the data type of <code>iterations</code>. <code>LOOKUP_TABLE default:</code> is a standard specification so that the default color lookup table will be used to map the scalar values (iterations) to colors in ParaView.</p> <p>Data iteration loop: This loop is necessary to iterate through the <code>iterations</code> vector and write each count to the VTK file.</p> <p>The line <code>ofs &lt;&lt; iterations[i] &lt;&lt; \"\\n\";</code> writes the number of iterations for each pixel to the output file.</p> <p>Checking the output: Once you have done this a \\texttt{.vtk} would have been created and when you open the file with VIM. <pre><code>vim mandelbrot_gradient_VTK.vtk \n</code></pre> The follow type of output should come. This is just an extraction of the file. <pre><code> vtk DataFile Version 3.0\nMandelbrot Set\nASCII\nDATASET STRUCTURED_POINTS\nDIMENSIONS 5000 5000 1\nORIGIN 0 0 0\nSPACING 1 1 1\nPOINT_DATA 25000000\nSCALARS mandelbrot_iterations int 1\nLOOKUP_TABLE default\n204\n204\n204\n204\n204\n204\n204\n// Rest of the file\n</code></pre></p> <p>Note that in the output file generated by the function you provided, the x and y coordinates of the points are not explicitly included in the output. This all has to do with the options that we used in This is the file we will use in the next subsection. If you want to include the coordinates you will need an output of this form. In a 2D output like for example image files, each pixel corresponds to a point in the complex plane and the use of x and y is implicit.  We will show you in the next section how to include the x,y coordinates when we use a 3D grid because the visualization requires knowledge of each point's position in a three-dimensional space. <pre><code> ofs &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; iterations[i] &lt;&lt; \"\\n\";\n</code></pre></p>"},{"location":"Visualization%20Techniques/The%20ParaView%20format/#paraview-installation","title":"ParaView installation:","text":"<p>First we need to install the software if you have not done so. If you are using Ubuntu, you can install ParaView either from the Ubuntu package manager as follows.</p> <p>Type this commands in your console. <pre><code>sudo apt update\nsudo apt install ParaView\n</code></pre></p> <p>And open ParaView. Once you open the program, you will be able to see the version you have downloaded. <pre><code>ParaView\n</code></pre> Alternatively, you can install ParaView by downloading the latest version directly from the official ParaView website: \\url{https://www.paraview.org/download/}. Copy the \\texttt{.tar.gz} file to the folder where you want to place ParaView. Then change directory to that folder and execute the following commands to uncompress the file. <pre><code>tar -xzf file_name_example\n</code></pre> Once you do that you can open the program with the following command. <pre><code>./ParaView\n</code></pre></p>"},{"location":"Visualization%20Techniques/The%20ParaView%20format/#2d-visualization","title":"2D Visualization","text":"<p>Lest zoom-in and capture the intricate structures of the set. For this replace in your code the following coordinates:</p> <p>The Islands region <pre><code>constexpr double X_MIN = -0.88;   // Minimum x-axis value for Islands region\nconstexpr double X_MAX = -0.84;   // Maximum x-axis value for Islands region\nconstexpr double Y_MIN = 0.215;   // Minimum y-axis value for Islands region\nconstexpr double Y_MAX = 0.255;   // Maximum y-axis value for Islands region\n</code></pre></p> <p>The Seahorse valley <pre><code>constexpr double X_MIN = -0.74877;    // Minimum x-axis value for Seahorse valley\nconstexpr double X_MAX = -0.74872;    // Maximum x-axis value for Seahorse valley\nconstexpr double Y_MIN = 0.06505;     // Minimum y-axis value for Seahorse valley\nconstexpr double Y_MAX = 0.06510;     // Maximum y-axis value for Seahorse valley\n</code></pre></p> <p>The double spiral <pre><code>constexpr double X_MIN = -1.0;    // Minimum x-axis value for double spiral\nconstexpr double X_MAX = -0.5;    // Maximum x-axis value for double spiral\nconstexpr double Y_MIN = -0.5;    // Minimum y-axis value for double spiral\nconstexpr double Y_MAX = 0.0;     // Maximum y-axis value for double spiral\n</code></pre></p> <p>Once you run your code you will obtain the following output in PPM or VTK respectiveley.</p> <p></p> <p>Figure: Seahorse valley in PPM format.</p> <p></p> <p>Figure: Double spiral region in PPM format.</p> <p></p> <p>Figure: Island region in VTK format-version 1.</p> <p></p> <p>Figure: Island region in VTK format-version 2.</p>"}]}